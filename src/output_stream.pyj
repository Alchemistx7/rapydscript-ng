# vim:fileencoding=utf-8
# License: BSD Copyright: 2016, Kovid Goyal <kovid at kovidgoyal.net>
# globals:regenerate

from utils import make_predicate, defaults, repeat_string, noop
from tokenizer import is_identifier_char
from ast import AST_Node

DANGEROUS = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g

def OutputStream(options):
    options = defaults(options, {
        'indent_start': 0,
        'indent_level': 4,
        'quote_keys': False,
        'space_colon': True,
        'ascii_only': False,
        'width': 80,
        'max_line_len': 32000,
        'ie_proof': True,
        'beautify': False,
        'source_map': None,
        'bracketize': False,
        'semicolons': True,
        'comments': False,
        'preserve_line': False,
        'omit_baselib': False,
        'baselib': None,
        'private_scope': True,
        'auto_bind': False,
        'js_version':5,
        'write_name': True
    }, True)
    indentation = 0
    current_col = 0
    current_line = 1
    current_pos = 0
    OUTPUT = ""
    IMPORTED = {}
    def to_ascii(str_, identifier):
        return str_.replace(/[\u0080-\uffff]/g, def(ch):
            code = ch.charCodeAt(0).toString(16)
            if code.length <= 2 and not identifier:
                while code.length < 2:
                    code = "0" + code

                return "\\x" + code
            else:
                while code.length < 4:
                    code = "0" + code

                return "\\u" + code

        )

    def encode_string(str_):
        return JSON.stringify(str_).replace(DANGEROUS, def(a):
                return '\\u' + a.charCodeAt(0).toString(16)
        )

    def make_name(name):
        name = name.toString()
        if options.ascii_only:
            name = to_ascii(name, True)

        return name

    def make_indent(back):
        return repeat_string(" ", options.indent_start + indentation - back * options.indent_level)

    # -----[ beautification/minification ]-----
    might_need_space = False
    might_need_semicolon = False
    last = None
    def last_char():
        return last.charAt(last.length - 1)

    def maybe_newline():
        if options.max_line_len and current_col > options.max_line_len:
            print_("\n")


    requireSemicolonChars = make_predicate("( [ + * / - , .")
    def print_(str_):
        nonlocal might_need_space, might_need_semicolon, last, current_line, current_pos, current_col, OUTPUT
        str_ = v"String(str_)"
        ch = str_.charAt(0)
        if might_need_semicolon:
            if (not ch or ";}".indexOf(ch) < 0) and not /[;]$/.test(last):
                if options.semicolons or requireSemicolonChars(ch):
                    OUTPUT += ";"
                    current_col += 1
                    current_pos += 1
                else:
                    OUTPUT += "\n"
                    current_pos += 1
                    current_line += 1
                    current_col = 0

                if not options.beautify:
                    might_need_space = False


            might_need_semicolon = False
            maybe_newline()

        if not options.beautify and options.preserve_line and stack[stack.length - 1]:
            target_line = stack[stack.length - 1].start.line
            while current_line < target_line:
                OUTPUT += "\n"
                current_pos += 1
                current_line += 1
                current_col = 0
                might_need_space = False


        if might_need_space:
            prev = last_char()
            if is_identifier_char(prev) and (is_identifier_char(ch) or ch is "\\")
            or /^[\+\-\/]$/.test(ch) and ch is prev:
                OUTPUT += " "
                current_col += 1
                current_pos += 1

            might_need_space = False

        a = str_.split(/\r?\n/)
        n = a.length - 1
        current_line += n
        if n is 0:
            current_col += a[n].length
        else:
            current_col = a[n].length

        current_pos += str_.length
        last = str_
        OUTPUT += str_

    space = options.beautify ? def(): print_(" ")
    : def():
        nonlocal might_need_space
        might_need_space = True

    indent = options.beautify ? def(half):
        if options.beautify:
            print_(make_indent((half ? 0.5 : 0)))
    : noop

    with_indent = options.beautify ? def(col, cont):
        nonlocal indentation
        if col is True:
            col = next_indent()

        save_indentation = indentation
        indentation = col
        ret = cont()
        indentation = save_indentation
        return ret
    : def(col, cont):
        return cont()

    def set_indentation(val):
        nonlocal indentation
        if options.beautify:
            indentation = val

    newline = options.beautify ? def():
        print_("\n")
    : noop

    semicolon = options.beautify ? def():
        print_(";")
    : def():
        nonlocal might_need_semicolon
        might_need_semicolon = True

    def force_semicolon():
        nonlocal might_need_semicolon
        might_need_semicolon = False
        print_(";")

    def next_indent():
        return indentation + options.indent_level

    def spaced():
        for v'var i=0; i < arguments.length; i++':
            if i > 0:
                space()
            if type(arguments[i].print) is 'function':
                arguments[i].print(this)
            else:
                print_(arguments[i])  # noqa:undef

    def end_statement():
        semicolon()
        newline()

    def with_block(cont):
        ret = None
        print_("{")
        newline()
        with_indent(next_indent(), def():
            nonlocal ret
            ret = cont()
        )
        indent()
        print_("}")
        return ret

    def with_parens(cont):
        print_("(")
        #XXX: still nice to have that for argument lists
        #var ret = with_indent(current_col, cont)
        ret = cont()
        print_(")")
        return ret

    def with_square(cont):
        print_("[")
        #var ret = with_indent(current_col, cont)
        ret = cont()
        print_("]")
        return ret

    def comma():
        print_(",")
        space()

    def colon():
        print_(":")
        if options.space_colon:
            space()


    add_mapping = (options.source_map ? def(token, name):
        try:
            if token:
                options.source_map.add(token.file or "?", current_line, current_col, token.line, token.col, (not name and token.type is "name" ? token.value : name))
        except:
            AST_Node.warn("Couldn't figure out mapping for {file}:{line},{col} â†’ {cline},{ccol} [{name}]", {
                'file': token.file,
                'line': token.line,
                'col': token.col,
                'cline': current_line,
                'ccol': current_col,
                'name': name or ""
            })
    : noop)

    # retrieve baselib function based on requested key
    def dump_baselib(key):
        indent()
        is_func = key.substr(key.length - 2) is '()'
        v = 'const' if options.js_version > 5 else 'var'
        if is_func:
            ckey = key.substr(0, key.length - 2)
            spaced(v, ckey, '=', '(')
        print_(options.baselib[key])
        if is_func:
            print_(')()')
        semicolon()
        newline()

    def dump_yield():
        indent()
        spaced('var', '_$rapyd$_regenerator', '=', '{}')
        end_statement()
        code = regenerate(False, options.beautify)
        if options.beautify:
            code = code.replace(/\/\/.*$/mg, '\n').replace(/^\s*$/gm, '')  # strip comments
            ci = make_indent(0)
            code = [ci + x for x in code.split('\n')].join('\n')
        print_(code + '(_$rapyd$_regenerator)')
        end_statement()

    # any code that should appear before the main body
    def prologue(module_):
        if options.omit_baselib:
            return
        indent()
        v = 'const' if options.js_version > 5 else 'var'
        print_(v), space()
        spaced.apply(None, (('_$rapyd$_iterator_symbol = (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") ? Symbol.iterator : "iterator-Symbol-5d0927e5554349048cf0e3762a228256"'.split(' '))))
        end_statement()
        indent(), print_(v), space()
        spaced.apply(None, (('_$rapyd$_kwargs_symbol = (typeof Symbol === "function") ? Symbol("kwargs-object") : "kwargs-object-Symbol-5d0927e5554349048cf0e3762a228256"'.split(' '))))
        end_statement()
        indent(), spaced('var', '_$rapyd$_cond_temp'), end_statement()
        indent(), spaced('var', '_$rapyd$_object_counter', '=', '0'), end_statement()
        baselib_items = {k:True for k in module_.baselib}
        baselib_items['errors'] = True
        baselib_items['containers'] = True
        baselib_items['builtins'] = True
        baselib_items['str'] = True
        deps = options.baselib['#dependencies#']
        # resolve dependencies
        for lib in baselib_items:
            if Object.prototype.hasOwnProperty.call(deps, lib):
                Object.keys(deps[lib]).forEach(def(k): baselib_items[k] = True;)
        # output used items
        for lib in baselib_items:
            if options.js_version >= 6 and (lib is 'iterable' or lib is 'yield'):
                continue
            if lib is 'yield':
                dump_yield()
            else:
                dump_baselib(lib)

    def get():
        return OUTPUT

    # generates: '[name] = '
    def assign_var(name):
        if typeof name is "string":
            print_(name)
        else:
            name.print(this)
        space()
        print_("=")
        space()

    stack = []
    return {
        'index_counter': 0,
        'with_counter': 0,
        'options':options,
        'get': get,
        'toString': get,
        'indent': indent,
        'indentation': def():
            return indentation
        ,
        'set_indentation': set_indentation,
        'make_indent': make_indent,
        'current_width': def():
            return current_col - indentation
        ,
        'should_break': def():
            return options.width and this.current_width() >= options.width
        ,
        'newline': newline,
        'print': print_,
        'space': space,
        'comma': comma,
        'colon': colon,
        'last': def():
            return last
        ,
        'semicolon': semicolon,
        'force_semicolon': force_semicolon,
        'to_ascii': to_ascii,
        'print_name': def(name):
            print_(make_name(name))
        ,
        'print_string': def(str_):
            print_(encode_string(str_))
        ,
        'next_indent': next_indent,
        'with_indent': with_indent,
        'with_block': with_block,
        'with_parens': with_parens,
        'spaced': spaced,
        'end_statement': end_statement,
        'with_square': with_square,
        'add_mapping': add_mapping,
        'assign': assign_var,
        'prologue': prologue,
        "import": def(module_):
            if not Object.prototype.hasOwnProperty.call(IMPORTED, module_.key):
                IMPORTED[module_.key] = module_
        ,
        'is_main': def():
            return OUTPUT.length is 0
        ,
        'option': def(opt):
            return options[opt]
        ,
        'line': def():
            return current_line
        ,
        'col': def():
            return current_col
        ,
        'pos': def():
            return current_pos
        ,
        'push_node': def(node):
            stack.push(node)
        ,
        'pop_node': def():
            return stack.pop()
        ,
        'stack': def():
            return stack
        ,
        'parent': def(n):
            return stack[stack.length - 2 - (n or 0)]

    }

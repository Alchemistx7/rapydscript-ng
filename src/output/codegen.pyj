# vim:fileencoding=utf-8
# License: BSD

# globals:console,regenerate,writefile

from utils import noop
from parse import PRECEDENCE
from ast import (
AST_Array, AST_Assign, AST_BaseCall, AST_Binary, AST_BlockStatement, AST_Break,
AST_Catch, AST_Class, AST_ClassCall, AST_Conditional, AST_Const, AST_Constant,
AST_Continue, AST_Debugger, AST_Definitions, AST_Directive, AST_Do, AST_Dot,
AST_EmptyStatement, AST_Exit, AST_ExpressiveObject, AST_Finally,
AST_ForIn, AST_ForJS, AST_Function, AST_Hole, AST_If, AST_Imports,
AST_Infinity, AST_Lambda, AST_ListComprehension, AST_LoopControl,
AST_NaN, AST_New, AST_Node, AST_Number, AST_Object, AST_ObjectKeyVal,
AST_ObjectProperty, AST_PropAccess, AST_RegExp, AST_Return, AST_Set,
AST_Seq, AST_SimpleStatement, AST_Splice, AST_Statement, AST_StatementWithBody,
AST_String, AST_Sub, AST_ItemAccess, AST_Symbol, AST_SymbolRef, AST_This,
AST_Throw, AST_Toplevel, AST_Try, AST_Unary, AST_UnaryPostfix, AST_UnaryPrefix,
AST_Undefined, AST_Var, AST_VarDef, AST_Verbatim, AST_While, AST_With,
AST_Yield, TreeWalker
)
from output.stream import OutputStream
from output.classes import print_class
from output.loops import print_do_loop, print_while_loop, print_for_loop_body, print_for_in, print_list_comprehension, unpack_tuple
from output.modules import print_top_level
from output.functions import decorate, function_definition
from output.statements import print_bracketed


# -----[ code generators ]-----
def generate_code():
    # -----[ utils ]-----
    def DEFPRINT(nodetype, generator):
        nodetype.DEFMETHOD("_codegen", generator)

    AST_Node.DEFMETHOD("print", def(stream, force_parens):
        self = this
        generator = self._codegen
        stream.push_node(self)
        if force_parens or self.needs_parens(stream):
            stream.with_parens(def():
                self.add_comments(stream)
                generator(self, stream)
            )
        else:
            self.add_comments(stream)
            generator(self, stream)

        stream.pop_node()
    )
    AST_Node.DEFMETHOD("print_to_string", def(options):
        s = OutputStream(options)
        this.print(s)
        return s.get()
    )
    # -----[ comments ]-----
    AST_Node.DEFMETHOD("add_comments", def(output):
        c = output.option("comments")
        self = this
        if c:
            start = self.start
            if start and not start._comments_dumped:
                start._comments_dumped = True
                comments = start.comments_before
                # XXX: ugly fix for https://github.com/mishoo/RapydScript2/issues/112
                #      if this node is `return` or `throw`, we cannot allow comments before
                #      the returned or thrown value.
                if isinstance(self, AST_Exit) and self.value and self.value.start.comments_before.length > 0:
                    comments = (comments or []).concat(self.value.start.comments_before)
                    self.value.start.comments_before = []

                if c.test:
                    comments = comments.filter(def(comment):
                        return c.test(comment.value)
                    )
                elif typeof c is "function":
                    comments = comments.filter(def(comment):
                        return c(self, comment)
                    )

                comments.forEach(def(c):
                    if c.type is "comment1":
                        output.print("//" + c.value + "\n")
                        output.indent()
                    elif c.type is "comment2":
                        output.print("/*" + c.value + "*/")
                        if start.nlb:
                            output.print("\n")
                            output.indent()
                        else:
                            output.space()


                )


    )
    # -----[ PARENTHESES ]-----
    def PARENS(nodetype, func):
        nodetype.DEFMETHOD("needs_parens", func)

    PARENS(AST_Node, def():
        return False
    )
    # a function expression needs parens around it when it's provably
    # the first token to appear in a statement.
    PARENS(AST_Function, def(output):
        return first_in_statement(output)
    )
    # same goes for an object literal, because otherwise it would be
    # interpreted as a block of code.
    PARENS(AST_Object, def(output):
        return first_in_statement(output)
    )
    PARENS(AST_Unary, def(output):
        p = output.parent()
        return isinstance(p, AST_PropAccess) and p.expression is this
    )
    PARENS(AST_Seq, def(output):
        p = output.parent()
        return isinstance(p, AST_Unary) or isinstance(p, AST_VarDef) or isinstance(p, AST_Dot) or isinstance(p, AST_ObjectProperty) or isinstance(p, AST_Conditional)
    )
    PARENS(AST_Binary, def(output):
        p = output.parent()
        # (foo && bar)()
        if isinstance(p, AST_BaseCall) and p.expression is this:
            return True

        # typeof (foo && bar)
        if isinstance(p, AST_Unary):
            return True

        # (foo && bar)["prop"], (foo && bar).prop
        if isinstance(p, AST_PropAccess) and p.expression is this:
            return True

        # this deals with precedence: 3 * (2 + 1)
        if isinstance(p, AST_Binary):
            po = p.operator
            pp = PRECEDENCE[po]
            so = this.operator
            sp = PRECEDENCE[so]
            if pp > sp or pp is sp and this is p.right and not (so is po and (so is "*" or so is "&&" or so is "||")):
                return True
    )
    PARENS(AST_PropAccess, def(output):
        p = output.parent()
        if isinstance(p, AST_New) and p.expression is this:
            # i.e. new (foo.bar().baz)
            #
            # if there's one call into this subtree, then we need
            # parens around it too, otherwise the call will be
            # interpreted as passing the arguments to the upper New
            # expression.
            try:
                this.walk(new TreeWalker(def(node):
                    if isinstance(node, AST_BaseCall):
                        raise p
                ))
            except as ex:
                if ex is not p:
                    raise ex
                return True
    )
    PARENS(AST_BaseCall, def(output):
        p = output.parent()
        return isinstance(p, AST_New) and p.expression is this
    )
    PARENS(AST_New, def(output):
        p = output.parent()
        if no_constructor_parens(this, output) and (isinstance(p, AST_PropAccess) or isinstance(p, AST_BaseCall) and p.expression is this):
            # (new foo)(bar)
            return True
    )
    PARENS(AST_Number, def(output):
        p = output.parent()
        if this.getValue() < 0 and isinstance(p, AST_PropAccess) and p.expression is this:
            return True
    )
    PARENS(AST_NaN, def(output):
        p = output.parent()
        if isinstance(p, AST_PropAccess) and p.expression is this:
            return True
    )
    def assign_and_conditional_paren_rules(output):
        p = output.parent()
        # !(a = false) → true
        if isinstance(p, AST_Unary):
            return True

        # 1 + (a = 2) + 3 → 6, side effect setting a = 2
        if isinstance(p, AST_Binary) and not (isinstance(p, AST_Assign)):
            return True

        # (a = func)() —or— new (a = Object)()
        if isinstance(p, AST_BaseCall) and p.expression is this:
            return True

        # (a = foo) ? bar : baz
        if isinstance(p, AST_Conditional) and p.condition is this:
            return True

        # (a = foo)["prop"] —or— (a = foo).prop
        if isinstance(p, AST_PropAccess) and p.expression is this:
            return True

    PARENS(AST_Assign, assign_and_conditional_paren_rules)
    PARENS(AST_Conditional, assign_and_conditional_paren_rules)
    # -----[ PRINTERS ]-----
    DEFPRINT(AST_Directive, def(self, output):
        output.print_string(self.value)
        output.semicolon()
    )
    DEFPRINT(AST_Debugger, def(self, output):
        output.print("debugger")
        output.semicolon()
    )
    AST_StatementWithBody.DEFMETHOD("_do_print_body", def(output):
        force_statement(this.body, output)
    )
    DEFPRINT(AST_Statement, def(self, output):
        self.body.print(output)
        output.semicolon()
    )
    DEFPRINT(AST_Toplevel, print_top_level)
    DEFPRINT(AST_Imports, def(container, output):
        def add_aname(aname, key, from_import):
            output.print('var ')
            output.assign(aname)
            output.print('_$rapyd$_modules["')
            output.print(key)
            output.print('"]')
            if from_import:
                output.print('.')
                output.print(from_import)
            output.semicolon()
            output.newline()
            output.indent()

        for self in container.imports:
            output.import_(self.module)
            if self.argnames:
                # A from import
                for argname in self.argnames:
                    akey = (argname.alias) ? argname.alias.name : argname.name
                    add_aname(akey, self.key, argname.name)
            else:
                if self.alias:
                    add_aname(self.alias.name, self.key, False)
                else:
                    bound_name = self.key.split('.', 1)[0]
                    add_aname(bound_name, bound_name, False)

    )
    DEFPRINT(AST_SimpleStatement, def(self, output):
        if not (isinstance(self.body, AST_EmptyStatement)):
            self.body.print(output)
            output.semicolon()
    )
    DEFPRINT(AST_BlockStatement, def(self, output):
        print_bracketed(self, output)
    )

    DEFPRINT(AST_EmptyStatement, def(self, output):
        pass
    )

    DEFPRINT(AST_Do, print_do_loop)

    DEFPRINT(AST_While, print_while_loop)

    AST_ForIn.DEFMETHOD("_do_print_body", print_for_loop_body)

    DEFPRINT(AST_ForIn, print_for_in)

    AST_ForJS.DEFMETHOD("_do_print_body", def(output):
        self = this
        output.with_block(def():
            self.body.body.forEach(def(stmt, i):
                output.indent()
                stmt.print(output)
                output.newline()
            )
        )
    )

    DEFPRINT(AST_ForJS, def(self, output):
        output.print("for")
        output.space()
        output.with_parens(def():
            self.condition.print(output)
        )
        output.space()
        self._do_print_body(output)
    )

    DEFPRINT(AST_ListComprehension, print_list_comprehension)

    DEFPRINT(AST_With, def(self, output):
        exits = v'[]'
        output.assign('_$rapyd$_with_exception'), output.print('undefined'), output.end_statement()
        for clause in self.clauses:
            output.with_counter += 1
            clause_name = '_$rapyd$_with_clause_' + output.with_counter
            exits.push(clause_name)
            output.indent(), output.print('var '), output.assign(clause_name)
            clause.expression.print(output)
            output.end_statement()
            output.indent()
            if clause.alias:
                output.assign(clause.alias.name)
            output.print(clause_name + '.__enter__()')
            output.end_statement()
        output.indent(), output.print('try'), output.space()
        output.with_block(def():
            output.indent()
            self._do_print_body(output)
            output.newline()
        )
        output.space(), output.print('catch(e)')
        output.with_block(def():
            output.indent(), output.assign('_$rapyd$_with_exception'), output.print('e'), output.end_statement()
        )
        output.newline(), output.indent(), output.spaced('if', '(_$rapyd$_with_exception', '===', 'undefined)')
        output.with_block(def():
            for clause in exits:
                output.indent(), output.print(clause + '.__exit__()'), output.end_statement()
        )
        output.space(), output.print('else'), output.space()
        output.with_block(def():
            output.indent(), output.assign('_$rapyd$_with_suppress'), output.print('false'), output.end_statement()
            for clause in exits:
                output.indent()
                output.spaced('_$rapyd$_with_suppress', '|=', '_$rapyd$_bool(' + clause + '.__exit__(_$rapyd$_with_exception.constructor,',
                              '_$rapyd$_with_exception,', '_$rapyd$_with_exception.stack))')
                output.end_statement()
            output.indent(), output.spaced('if', '(!_$rapyd$_with_suppress)', 'throw _$rapyd$_with_exception'), output.end_statement()
        )

    )

    AST_Lambda.DEFMETHOD("_do_print", def(output, nokeyword):
        self = this
        if self.decorators and self.decorators.length:
            output.print("var")
            output.space()
            output.assign(self.name.name)
            decorate(self.decorators, output, def():function_definition(self, output, nokeyword, False);)
            output.semicolon()
        else:
            function_definition(self, output, nokeyword, False)
    )
    DEFPRINT(AST_Lambda, def(self, output):
        self._do_print(output)
    )
    AST_Class.DEFMETHOD("_do_print", print_class)
    DEFPRINT(AST_Class, def(self, output):
        self._do_print(output)
    )
    # -----[ exits ]-----
    AST_Exit.DEFMETHOD("_do_print", def(output, kind):
        self = this
        output.print(kind)
        if self.value:
            output.space()
            self.value.print(output)

        output.semicolon()
    )
    DEFPRINT(AST_Yield, def(self, output):
        self._do_print(output, "yield" + (self.is_yield_from ? '*' : ''))
    )
    DEFPRINT(AST_Return, def(self, output):
        self._do_print(output, "return")
    )
    DEFPRINT(AST_Throw, def(self, output):
        self._do_print(output, "throw")
    )

    # -----[ loop control ]-----
    AST_LoopControl.DEFMETHOD("_do_print", def(output, kind):
        output.print(kind)
        if this.label:
            output.space()
            this.label.print(output)

        output.semicolon()
    )
    DEFPRINT(AST_Break, def(self, output):
        self._do_print(output, "break")
    )
    DEFPRINT(AST_Continue, def(self, output):
        self._do_print(output, "continue")
    )

    # -----[ if ]-----
    def make_then(self, output):
        if output.option("bracketize"):
            make_block(self.body, output)
            return

        # The squeezer replaces "block"-s that contain only a single
        # statement with the statement itself; technically, the AST
        # is correct, but this can create problems when we output an
        # IF having an ELSE clause where the THEN clause ends in an
        # IF *without* an ELSE block (then the outer ELSE would refer
        # to the inner IF).  This function checks for this case and
        # adds the block brackets if needed.
        if not self.body:
            return output.force_semicolon()

        if isinstance(self.body, AST_Do) and output.option("ie_proof"):
            # https://github.com/mishoo/RapydScript/issues/#issue/57 IE
            # croaks with "syntax error" on code like this: if (foo)
            # do ... while(cond); else ...  we need block brackets
            # around do/while
            make_block(self.body, output)
            return

        b = self.body
        while True:
            if isinstance(b, AST_If):
                if not b.alternative:
                    make_block(self.body, output)
                    return

                b = b.alternative
            elif isinstance(b, AST_StatementWithBody):
                b = b.body
            else:
                break

        force_statement(self.body, output)

    DEFPRINT(AST_If, def(self, output):
        output.print("if")
        output.space()
        output.with_parens(def(): self.condition.print(output);)
        output.space()
        if self.alternative:
            make_then(self, output)
            output.space()
            output.print("else")
            output.space()
            force_statement(self.alternative, output)
        else:
            self._do_print_body(output)

    )

    # -----[ exceptions ]-----
    DEFPRINT(AST_Try, def(self, output):
        output.print("try")
        output.space()
        print_bracketed(self, output)
        if self.bcatch:
            output.space()
            self.bcatch.print(output)

        if self.bfinally:
            output.space()
            self.bfinally.print(output)
    )
    DEFPRINT(AST_Catch, def(self, output):
        output.print("catch")
        output.space()
        output.with_parens(def():
            output.print("_$rapyd$_Exception")
        )
        output.space()
        #        print_bracketed(self, output)
        if self.body.length > 1 or self.body[0].errors.length:
            output.with_block(def():
                output.indent()
                no_default = True
                self.body.forEach(def(exception, i):
                    nonlocal no_default
                    if i:
                        output.print("else ")

                    if exception.errors.length:
                        output.print("if")
                        output.space()
                        output.with_parens(def():
                            exception.errors.forEach(def(err, i):
                                if i:
                                    output.newline()
                                    output.indent()
                                    output.print("||")
                                    output.space()

                                output.print("_$rapyd$_Exception")
                                output.space()
                                output.print("instanceof")
                                output.space()
                                err.print(output)
                            )
                        )
                        output.space()
                    else:
                        no_default = False
                    print_bracketed(exception, output, True)
                    output.space()
                )
                if no_default:
                    output.print("else")
                    output.space()
                    output.with_block(def():
                        output.indent()
                        output.print("throw")
                        output.space()
                        output.print("_$rapyd$_Exception")
                        output.semicolon()
                        output.newline()
                    )
                output.newline()
            )
        else:
            print_bracketed(self.body[0], output, True)
    )
    DEFPRINT(AST_Finally, def(self, output):
        output.print("finally")
        output.space()
        print_bracketed(self, output)
    )

    # -----[ var/const ]-----
    AST_Definitions.DEFMETHOD("_do_print", def(output, kind):
        output.print(kind)
        output.space()
        this.definitions.forEach(def(def_, i):
            if i:
                output.comma()
            def_.print(output)
        )
        p = output.parent()
        in_for = isinstance(p, AST_ForIn)
        avoid_semicolon = in_for and p.init is this
        if not avoid_semicolon:
            output.semicolon()
    )
    DEFPRINT(AST_Var, def(self, output):
        self._do_print(output, "var")
    )
    DEFPRINT(AST_Const, def(self, output):
        self._do_print(output, "const")
    )
    def parenthesize_for_noin(node, output, noin):
        if not noin:
            node.print(output)
        else:
            try:
                # need to take some precautions here:
                #    https://github.com/mishoo/RapydScript2/issues/60
                node.walk(new TreeWalker(def(node):
                    if isinstance(node, AST_Binary) and node.operator is "in":
                        raise output
                ))
                node.print(output)
            except as ex:
                if ex is not output:
                    raise ex
                node.print(output, True)

    DEFPRINT(AST_VarDef, def(self, output):
        self.name.print(output)
        if self.value:
            output.assign("")
            #            output.space()
            #            output.print("=")
            #            output.space()
            p = output.parent(1)
            noin = isinstance(p, AST_ForIn)
            parenthesize_for_noin(self.value, output, noin)
    )

    # -----[ other expressions ]-----
    DEFPRINT(AST_BaseCall, def(self, output):

        if isinstance(self, AST_ClassCall):
            # class methods are called through the prototype unless static
            if self.static:
                self.class.print(output)
                output.print(".")
                output.print(self.method)
            else:
                self.class.print(output)
                output.print(".prototype.")
                output.print(self.method)
                output.print(".call")
        else:
            # regular function call
            self.expression.print(output)

        if isinstance(self, AST_New) and no_constructor_parens(self, output):
            return

        has_kwarg_items = self.args.kwarg_items and self.args.kwarg_items.length
        has_kwarg_formals = self.args.kwargs and self.args.kwargs.length
        has_kwargs = has_kwarg_items or has_kwarg_formals

        output_kwargs = def():
            output.print('_$rapyd$_desugar_kwargs(')
            if has_kwarg_items:
                self.args.kwarg_items.forEach(def(kwname, i):
                    if i > 0:
                        output.print(',')
                        output.space()
                    kwname.print(output)
                )
                if has_kwarg_formals:
                    output.print(',')
                    output.space()

            if has_kwarg_formals:
                output.print('{')
                self.args.kwargs.forEach(def(pair, i):
                    if i: output.comma()
                    pair[0].print(output)
                    output.print(':')
                    output.space()
                    pair[1].print(output)
                )
                output.print('}')
            output.print(')')

        if self.args.starargs:
            if isinstance(self, AST_New):
                obj = '_$rapyd$_new_temp'
            else:
                obj = (self.expression.expression ? self.expression.expression : "this")
            output.print(".apply")
            output.with_parens(def():
                if type(obj) is 'string':
                    output.print(obj)
                else:
                    obj.print(output)
                output.comma()
                # basic arguments
                i = 0
                while i < self.args.length:
                    expr = self.args[i]
                    is_first = i is 0
                    if not is_first:
                        output.print('.concat(')
                    if expr.is_array:
                        expr.print(output)
                        i += 1
                    else:
                        output.print('[')
                        while i < self.args.length and not self.args[i].is_array:
                            self.args[i].print(output)
                            if i + 1 < self.args.length and not self.args[i+1].is_array:
                                output.print(',')
                                output.space()
                            i += 1
                        output.print(']')
                    if not is_first:
                        output.print(')')

                # now kwargs
                if has_kwargs:
                    if self.args.length:
                        output.print('.concat(')
                    output.print('[')
                    output_kwargs()
                    output.print(']')
                    if self.args.length:
                        output.print(')')
            )
        else:
            output.with_parens(def():
                # normal args
                self.args.forEach(def(expr, i):
                    if i:
                        output.comma()
                    expr.print(output)
                )

                # kwargs as hash
                if has_kwargs:
                    if self.args.length:
                        output.print(',')
                        output.space()
                    output_kwargs()
            )
    )
    DEFPRINT(AST_New, def(self, output):
        if self.args.starargs:
            output.with_parens(def():
                output.print('function()')
                output.with_block(def():
                    output.indent()
                    output.print('var _$rapyd$_new_temp = Object.create(')
                    self.expression.print(output)
                    output.print(')')
                    output.end_statement(), output.indent()
                    AST_BaseCall.prototype._codegen(self, output)
                    output.end_statement(), output.indent()
                    output.print('return _$rapyd$_new_temp')
                    output.end_statement()
                )
            )
            output.print('()')
        else:
            output.print("new")
            output.space()
            AST_BaseCall.prototype._codegen(self, output)
    )
    AST_Seq.DEFMETHOD("_do_print", def(output):
        self = this
        p = output.parent()
        print_seq = def():
            self.car.print(output)
            if self.cdr:
                output.comma()
                if output.should_break():
                    output.newline()
                    output.indent()
                self.cdr.print(output)

        # this will effectively convert tuples to arrays
        if isinstance(p, AST_Binary)
        or isinstance(p, AST_Return)
        or isinstance(p, AST_Array)
        or isinstance(p, AST_BaseCall)
        or isinstance(p, AST_SimpleStatement):
            output.with_square(print_seq)
        else:
            print_seq()
    )
    DEFPRINT(AST_Seq, def(self, output):
        self._do_print(output)
    )
    DEFPRINT(AST_Dot, def(self, output):
        expr = self.expression
        expr.print(output)
        if isinstance(expr, AST_Number) and expr.getValue() >= 0:
            if not /[xa-f.]/i.test(output.last()):
                output.print(".")
        output.print(".")
        # the name after dot would be mapped about here.
        output.print_name(self.property)
    )
    DEFPRINT(AST_Sub, def(self, output):
        self.expression.print(output)
        output.print("[")
        # parse negative constants into len-constant
        if isinstance(self.property, AST_Unary) and self.property.operator is "-"
        and isinstance(self.property.expression, AST_Number):
            # TODO: this might parse incorrectly if expression is a
            # function call that might not return the same result
            # when called repeatedly. We might eventually want to
            # save the return to a temporary variable and use that
            # instead if expression is a function. Or we could just
            # throw an error if negative indices are used with a
            # type that's not AST_SymbolVar
            self.expression.print(output)
            output.print(".length")

        self.property.print(output)
        output.print("]")
    )
    DEFPRINT(AST_ItemAccess, def(self, output):
        self.expression.print(output)
        output.print('.__' + (self.assignment ? 'setitem' : 'getitem') + '__')
        output.with_parens(def():
            self.property.print(output)
            if self.assignment:
                output.comma()
                self.assignment.print(output)
        )
    )
    DEFPRINT(AST_Splice, def(self, output):
        # splice assignment via pythonic array[start:end]
        output.print('[].splice.apply')
        output.with_parens(def():
            self.expression.print(output)
            output.comma()
            output.with_square(def():
                self.property.print(output)
                output.comma()
                self.property2.print(output)
                output.print('-')
                self.property.print(output)
            )
            output.print('.concat')
            output.with_parens(def():
                self.assignment.print(output)
            )
        )
    )
    DEFPRINT(AST_UnaryPrefix, def(self, output):
        op = self.operator
        output.print(op)
        if /^[a-z]/i.test(op):
            output.space()
        self.expression.print(output)
    )
    DEFPRINT(AST_UnaryPostfix, def(self, output):
        self.expression.print(output)
        output.print(self.operator)
    )
    def write_instanceof(left, right, output):
        def single(left, right):
            if right.name is 'Array' or right.name is 'list':
                output.print('Array.isArray')
                output.with_parens(def():left.print(output);)
            else:
                output.spaced(left, 'instanceof', right)
        if isinstance(right, AST_Seq):
            right = new AST_Array({'elements':right.to_array()})
        if isinstance(right, AST_Array):
            output.with_parens(def():
                right.elements.forEach(def (right, i, arr):
                    single(left, right)
                    if arr.length > 1 and i < arr.length - 1:
                        output.space(), output.print('||'), output.space()
                )
            )
        else:
            single(left, right)

    def write_smart_equality(self, output):
        def is_ok(x):
            return not isinstance(x, (AST_Array, AST_Set, AST_Object, AST_Statement, AST_Binary, AST_Conditional, AST_BaseCall))
        if is_ok(self.left) and is_ok(self.right):
            if self.operator is '==':
                output.print('(')
                output.spaced(self.left, '===', self.right, '||', 'typeof', self.left, '===', '"object"', '&&', '_$rapyd$_equals(')
                self.left.print(output), output.print(','), output.space(), self.right.print(output), output.print('))')
            else:
                output.print('(')
                output.spaced(self.left, '!==', self.right, '&&', '(typeof', self.left, '!==', '"object"', '||', '_$rapyd$_not_equals(')
                self.left.print(output), output.print(','), output.space(), self.right.print(output), output.print(')))')
        else:
            output.print('_$rapyd$_' + ('equals(' if self.operator is '==' else 'not_equals('))
            self.left.print(output), output.print(','), output.space(), self.right.print(output), output.print(')')

    DEFPRINT(AST_Binary, def(self, output):
        comparators = {
            "<": True,
            ">": True,
            "<=": True,
            ">=": True,
            "==": True,
            "!=": True
        }
        function_ops = {
            "in": "_$rapyd$_in",
            "**": "Math.pow"
        }

        if self.operator in function_ops:
            output.print(function_ops[self.operator])
            output.with_parens(def():
                self.left.print(output)
                output.comma()
                self.right.print(output)
            )
        elif comparators[self.operator] and isinstance(self.left, AST_Binary) and comparators[self.left.operator]:
            if isinstance(self.left.right, AST_Symbol):
                # left side compares against a regular variable,
                # no caching needed
                self.left.print(output)
                leftvar = self.left.right.name
            else:
                # some logic is being performed, let's cache it
                self.left.left.print(output)
                output.space()
                output.print(self.left.operator)
                output.space()
                output.with_parens(def():
                    nonlocal leftvar
                    output.assign("_$rapyd$_cond_temp")
                    self.left.right.print(output)
                    leftvar = "_$rapyd$_cond_temp"
                )

            output.space()
            output.print("&&")
            output.space()
            output.print(leftvar)
            output.space()
            output.print(self.operator)
            output.space()
            self.right.print(output)
        elif self.operator is '//':
            output.print('Math.floor')
            output.with_parens(def():
                self.left.print(output)
                output.space()
                output.print('/')
                output.space()
                self.right.print(output)
            )
        elif self.operator is '==' or self.operator is '!=':
            write_smart_equality(self, output)
        elif self.operator is 'instanceof':
            write_instanceof(self.left, self.right, output)
        else:
            output.spaced(self.left, self.operator, self.right)
    )

    def print_assignment(self, output):
        flattened = False
        left = self.left
        if isinstance(left, AST_Seq):
            left = new AST_Array({'elements':v'[left.car, left.cdr]'})
        if isinstance(left, AST_Array):
            flat = left.flatten()
            flattened = flat.length > left.elements.length
            output.print("_$rapyd$_unpack")
        else:
            left.print(output)
        output.space()
        output.print(self.operator)
        output.space()
        if flattened:
            output.print('_$rapyd$_flatten')
            output.with_parens(def():self.right.print(output);)
        else:
            self.right.print(output)
        if isinstance(left, AST_Array):
            output.semicolon()
            output.newline()
            unpack_tuple(flat, output, True)

    DEFPRINT(AST_Assign, def(self, output):
        if self.operator is '//=':
            output.assign(self.left)
            output.print('Math.floor')
            output.with_parens(def():
                self.left.print(output)
                output.space()
                output.print('/')
                output.space()
                self.right.print(output)
            )
            return
        if self.operator is '=' and self.is_chained():
            left_hand_sides, rhs = self.traverse_chain()
            temp_rhs = new AST_SymbolRef({'name':'_$rapyd$_chain_assign_temp'})
            print_assignment(new AST_Assign({'left':temp_rhs, 'operator':'=', 'right':rhs}), output)
            output.end_statement(), output.indent()
            for lhs in left_hand_sides:
                print_assignment(new AST_Assign({'left':lhs, 'right':temp_rhs, 'operator':self.operator}), output)
                output.end_statement()
                if lhs is not left_hand_sides[-1]:
                    output.indent()
        else:
            print_assignment(self, output)

    )
    def write_conditional(output, condition, consequent, alternative):
        output.with_parens(def():condition.print(output);)
        output.space()
        output.print("?")
        output.space()
        consequent.print(output)
        output.space()
        output.colon()
        alternative.print(output)

    DEFPRINT(AST_Conditional, def(self, output):
        write_conditional(output, self.condition, self.consequent, self.alternative)
    )

    # -----[ literals ]-----
    DEFPRINT(AST_Array, def(self, output):
        output.print('_$rapyd$_list_decorate')
        output.with_parens(def():
            output.with_square(def():
                a = self.elements
                len_ = a.length
                if len_ > 0:
                    output.space()
                a.forEach(def(exp, i):
                    if i:
                        output.comma()
                    exp.print(output)
                )
                if len_ > 0:
                    output.space()
            )
        )
    )

    def write_obj_literal(self, output):
        output.with_parens(def():
            output.print('function()')
            output.with_block(def():
                output.indent()
                if self.is_pydict:
                    output.spaced.apply(output, 'var _$rapyd$_d = _$rapyd$_dict()'.split(' '))
                else:
                    output.spaced.apply(output, 'var _$rapyd$_d = {}'.split(' '))
                output.end_statement()
                self.properties.forEach(def(prop, i):
                    output.indent()
                    if self.is_pydict:
                        output.print('_$rapyd$_d.set')
                        output.with_parens(def():
                            prop.key.print(output)
                            output.print(','), output.space()
                            prop.value.print(output)
                        )
                    else:
                        output.print('_$rapyd$_d')
                        output.with_square(def():prop.key.print(output);)
                        output.space(), output.print('='), output.space()
                        prop.value.print(output)
                    output.end_statement()
                )
                output.indent()
                output.spaced('return', '_$rapyd$_d')
                output.end_statement()
            )
        )
        output.print('()')

    DEFPRINT(AST_ExpressiveObject, write_obj_literal)

    DEFPRINT(AST_Object, def(self, output):
        if self.is_pydict:
            if self.properties.length > 0:
                write_obj_literal(self, output)
            else:
                output.print('_$rapyd$_dict()')
        else:
            if self.properties.length > 0:
                output.with_block(def():
                    self.properties.forEach(def(prop, i):
                        if i:
                            output.print(",")
                            output.newline()
                        output.indent()
                        prop.print(output)
                    )
                    output.newline()
                )
            else:
                output.print("{}")
    )
    DEFPRINT(AST_ObjectKeyVal, def(self, output):
        self.key.print(output)
        output.colon()
        self.value.print(output)
    )
    DEFPRINT(AST_Set, def(self, output):
        if self.items.length is 0:
            output.print('_$rapyd$_set()')
            return
        output.with_parens(def():
            output.print('function()')
            output.with_block(def():
                output.indent()
                output.spaced.apply(output, 'var s = _$rapyd$_set()'.split(' '))
                output.end_statement()
                self.items.forEach(def(item, i):
                    output.indent()
                    output.print('s.jsset.add')
                    output.with_parens(def():item.value.print(output);)
                    output.end_statement()
                )
                output.indent()
                output.spaced('return', 's')
                output.end_statement()
            )
        )
        output.print('()')
    )
    AST_Symbol.DEFMETHOD("definition", def():
        return this.thedef
    )
    DEFPRINT(AST_Symbol, def(self, output):
        def_ = self.definition()
        output.print_name((def_ ? def_.mangled_name or def_.name : self.name))
    )
    DEFPRINT(AST_Undefined, def(self, output):
        output.print("void 0")
    )
    DEFPRINT(AST_Hole, noop)
    DEFPRINT(AST_Infinity, def(self, output):
        output.print("1/0")
    )
    DEFPRINT(AST_NaN, def(self, output):
        output.print("0/0")
    )
    DEFPRINT(AST_This, def(self, output):
        output.print("this")
    )
    DEFPRINT(AST_Constant, def(self, output):
        output.print(self.getValue())
    )
    DEFPRINT(AST_String, def(self, output):
        output.print_string(self.getValue())
    )
    DEFPRINT(AST_Verbatim, def(self, output):
        output.print(self.getValue())
    )
    DEFPRINT(AST_Number, def(self, output):
        output.print(make_num(self.getValue()))
    )
    DEFPRINT(AST_RegExp, def(self, output):
        str_ = self.getValue().toString()
        if output.option("ascii_only"):
            str_ = output.to_ascii(str_)
        output.print(str_)
        p = output.parent()
        if isinstance(p, AST_Binary) and /^in/.test(p.operator) and p.left is self:
            output.print(" ")
    )
    def force_statement(stat, output):
        if output.option("bracketize"):
            if not stat or isinstance(stat, AST_EmptyStatement):
                output.print("{}")
            elif isinstance(stat, AST_BlockStatement):
                stat.print(output)
            else:
                output.with_block(def():
                    output.indent()
                    stat.print(output)
                    output.newline()
                )
        else:
            if not stat or isinstance(stat, AST_EmptyStatement):
                output.force_semicolon()
            else:
                stat.print(output)

    # return true if the node at the top of the stack (that means the
    # innermost node in the current output) is lexically the first in
    # a statement.
    def first_in_statement(output):
        a = output.stack()
        i = a.length
        node = a[i -= 1]
        p = a[i -= 1]
        while i > 0:
            if isinstance(p, AST_Statement) and p.body is node:
                return True
            if isinstance(p, AST_Seq) and p.car is node
            or isinstance(p, AST_BaseCall) and p.expression is node
            or isinstance(p, AST_Dot) and p.expression is node
            or isinstance(p, AST_Sub) and p.expression is node
            or isinstance(p, AST_ItemAccess) and p.expression is node
            or isinstance(p, AST_Conditional) and p.condition is node
            or isinstance(p, AST_Binary) and p.left is node
            or isinstance(p, AST_UnaryPostfix) and p.expression is node:
                node = p
                p = a[i -= 1]
            else:
                return False

    # self should be AST_New.  decide if we want to show parens or not.
    def no_constructor_parens(self, output):
        return self.args.length is 0 and not output.option("beautify")

    def best_of(a):
        best = a[0]
        len_ = best.length
        for i in range(1, a.length):
            if a[i].length < len_:
                best = a[i]
                len_ = best.length
        return best

    def make_num(num):
        str_ = num.toString(10)
        a = [ str_.replace(/^0\./, ".").replace("e+", "e") ]
        m = None

        if Math.floor(num) is num:
            if num >= 0:
                a.push("0x" + num.toString(16).toLowerCase(), # probably pointless
                "0" + num.toString(8))
            else:
                a.push("-0x" + (-num).toString(16).toLowerCase(), # probably pointless
                "-0" + (-num).toString(8))

            if m = /^(.*?)(0+)$/.exec(num):
                a.push(m[1] + "e" + m[2].length)

        elif m = /^0?\.(0+)(.*)$/.exec(num):
            a.push(m[2] + "e-" + (m[1].length + m[2].length), str_.substr(str_.indexOf(".")))

        return best_of(a)

    def make_block(stmt, output):
        if isinstance(stmt, AST_BlockStatement):
            stmt.print(output)
            return

        output.with_block(def():
            output.indent()
            stmt.print(output)
            output.newline()
        )

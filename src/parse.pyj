# vim:fileencoding=utf-8
# License: BSD

"use strict"

from utils import make_predicate, array_to_hash, defaults
from errors import SyntaxError, ImportError
from ast import (
AST_Accessor, AST_Array, AST_Assign, AST_Binary, AST_BlockStatement, AST_Break,
AST_Call, AST_Case, AST_Catch, AST_Class, AST_ClassCall, AST_Conditional,
AST_Const, AST_Constant, AST_Continue, AST_DWLoop, AST_Debugger, AST_Decorator,
AST_Default, AST_Definitions, AST_DictComprehension, AST_Directive, AST_Do,
AST_Dot, AST_EmptyStatement, AST_Except, AST_Exit, AST_ExpressiveObject,
AST_False, AST_Finally, AST_ForIn, AST_ForJS, AST_Function, AST_Hole, AST_If,
AST_Import, AST_ImportedVar, AST_Imports, AST_ListComprehension, AST_Method,
AST_New, AST_Null, AST_Number, AST_Object, AST_ObjectKeyVal, AST_PropAccess,
AST_RegExp, AST_Return, AST_Scope, AST_Set, AST_SetComprehension, AST_SetItem,
AST_Seq, AST_SimpleStatement, AST_Splice, AST_String, AST_Sub, AST_Switch,
AST_SymbolAccessor, AST_SymbolAlias, AST_SymbolCatch, AST_SymbolConst,
AST_SymbolDefun, AST_SymbolFunarg, AST_SymbolLambda, AST_SymbolNonlocal,
AST_SymbolRef, AST_SymbolVar, AST_This, AST_Throw, AST_Toplevel, AST_True,
AST_Try, AST_UnaryPostfix, AST_UnaryPrefix, AST_Undefined, AST_Var, AST_VarDef,
AST_Verbatim, AST_While, AST_With, AST_Yield
)
from tokenizer import tokenizer, is_token, UNARY_POSTFIX


COMPILER_VERSION = '__COMPILER_VERSION__'

NATIVE_CLASSES = {
    'Image': {},
    'RegExp': {},
    'Error': {},
    'Object': {
        'static': [ "getOwnPropertyNames", "keys", "create" ]
    },
    'String': {
        'static': [ "fromCharCode" ]
    },
    'Array': {
        'static': [ "isArray", "from", "of" ]
    },
    'Number': {
        'static': [ "isFinite", "isNaN" ]
    },
    'Function': {},
    'Date': {
        'static': [ "UTC", "now", "parse" ]
    },
    'Boolean': {},
    'ArrayBuffer': {},
    'DataView': {},
    'Float32Array': {},
    'Float64Array': {},
    'Int16Array': {},
    'Int32Array': {},
    'Int8Array': {},
    'Uint16Array': {},
    'Uint32Array': {},
    'Uint8Array': {},
    'Uint8ClampedArray': {},
    'Map': {},
    'WeakMap': {},
    'Set': {},
    'WeakSet': {},
    'Symbol': {},
}
ERROR_CLASSES = {
    'Exception': {},
    'AttributeError': {},
    'IndexError': {},
    'KeyError': {},
    'ValueError': {},
}
COMMON_STATIC = [ "call", "apply", "bind", "toString" ]

# -----[ Parser (constants) ]-----
UNARY_PREFIX = make_predicate([
    "typeof",
    "void",
    "delete",
    "--",
    "++",
    "!",
    "~",
    "-",
    "+",
    "@"
])


ASSIGNMENT = make_predicate([ "=", "+=", "-=", "/=", "//=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&=" ])

PRECEDENCE = def(a, ret):
    for i in range(a.length):
        b = a[i]
        for j in range(b.length):
            ret[b[j]] = i+1
    return ret
.call(this, [
    # lowest precedence
    [ "||" ],
    [ "&&" ],
    [ "|" ],
    [ "^" ],
    [ "&" ],
    [ "==", "===", "!=", "!==" ],
    [ "<", ">", "<=", ">=", "in", "instanceof" ],
    [ ">>", "<<", ">>>" ],
    [ "+", "-" ],
    [ "*", "/", "//", "%" ],
    [ "**" ]
    # highest precedence
], {})

STATEMENTS_WITH_LABELS = array_to_hash([ "for", "do", "while", "switch" ])

ATOMIC_START_TOKEN = array_to_hash([ "atom", "num", "string", "regexp", "name" ])

# -----[ Parser ]-----
def parse($TEXT, options):
    options = defaults(options, {
        'strict': False,      # whether to use strict JavaScript mode
        'filename': None,     # name of the file being parsed
        'auto_bind': False,   # whether auto-binding of methods to classes is enabled
        'module_id':'__main__', # The id of the module being parsed
        'toplevel': None,
        'for_linting': False, # If True certain actions are not performed, such as importing modules
        'classes': undefined  # Map of class names to AST_Class that are available in the global namespace (used by the REPL)
    })
    module_id = options.module_id
    baselib_items = {}
    imported_module_ids = []
    IMPORTED = options.IMPORTED or {}
    IMPORTING = options.IMPORTING or {}
    IMPORTING[module_id] = True

    S = {
        'input': (typeof $TEXT == "string" ? tokenizer($TEXT, options.filename) : $TEXT),
        'token': None,
        'prev': None,
        'peeked': [],
        'in_function': 0,
        'in_directives': True,
        'statement_starting_token': None,
        'in_comprehension': False,
        'in_parenthesized_expr': False,
        'in_loop': 0,
        'in_class': [ False ],
        'classes': [ {} ],
        'functions': [ {} ],
        'labels': [],
        'decorators': [],
    }

    if options.classes:
        for cname in options.classes:
            obj = options.classes[cname]
            S.classes[0][cname] = { 'static':obj.static, 'bound':obj.bound }

    def next():
        S.prev = S.token
        if S.peeked.length:
            S.token = S.peeked.shift()
        else:
            S.token = S.input()

        S.in_directives = S.in_directives and (S.token.type == "string" or is_("punc", ";"))
        return S.token

    S.token = next()

    def is_(type, value):
        return is_token(S.token, type, value)

    def peek():
        if not S.peeked.length:
            S.peeked.push(S.input())
        return S.peeked[0]

    def prev():
        return S.prev

    def croak(msg, line, col, pos, is_eof):
        # note: undefined means nothing was passed in, None/null means a null value was passed in
        ctx = S.input.context()
        raise new SyntaxError(msg, ctx.filename, (line != undefined ? line : ctx.tokline),
                 (col != undefined ? col : ctx.tokcol), (pos != undefined ? pos : ctx.tokpos), is_eof)

    def token_error(token, msg):
        is_eof = (token.type == 'eof') ? True : False
        croak(msg, token.line, token.col, undefined, is_eof)

    def unexpected(token):
        if token == undefined:
            token = S.token
        token_error(token, "Unexpected token: " + token.type + " «" + token.value + "»")

    def expect_token(type, val):
        if is_(type, val):
            return next()
        token_error(S.token, "Unexpected token " + S.token.type + " «" + S.token.value + "»" +
                    ", expected " + type + " «" + val + "»")

    def expect(punc):
        return expect_token("punc", punc)

    def can_insert_semicolon():
        return not options.strict and (S.token.nlb or is_("eof") or is_("punc", "}"))

    def semicolon():
        if is_("punc", ";"):
            next()
            S.token.nlb = True

    def parenthesised():
        expect("(")
        exp = expression(True)
        expect(")")
        return exp

    def embed_tokens(parser):
        return def():
            start = S.token
            expr = parser()
            if expr == undefined:
                unexpected()
            end = prev()
            expr.start = start
            expr.end = end
            return expr

    def is_nested_comparison(stmt):
        """
        Check if the statement is a nested comparison
        """
        comparators = {
            "<": True,
            ">": True,
            "<=": True,
            ">=": True,
            "==": True,
            "!=": True,
            "===": True,
            "!==": True
        }
        if isinstance(stmt, AST_Binary) and stmt.operator in comparators \
                and isinstance(stmt.left, AST_Binary) and stmt.left.operator in comparators:
            return True
        else:
            return False

    def scan_for_top_level_callables(body):
        ans = []
        # Get the named functions and classes
        if Array.isArray(body):
            for name in dir(body):
                obj = body[name]
                if isinstance(obj, AST_Function) or isinstance(obj, AST_Class):
                    ans.push(obj.name)
                else:
                    # skip inner scopes
                    if isinstance(obj, AST_Scope):
                        continue
                    for x in ['body', 'alternative']:
                        opt = obj[x]
                        if opt:
                            ans = ans.concat(scan_for_top_level_callables(opt))

                        if isinstance(opt, AST_Assign) and not (isinstance(opt.right, AST_Scope)):
                            ans = ans.concat(scan_for_top_level_callables(opt.right))

        elif body.body:
            # recursive descent into wrapper statements that contain body blocks
            ans = ans.concat(scan_for_top_level_callables(body.body))
            if body.alternative:
                ans = ans.concat(scan_for_top_level_callables(body.alternative))


        return ans

    def scan_for_classes(body):
        ans = {}
        for name in dir(body):
            obj = body[name]
            if isinstance(obj, AST_Class):
                ans[obj.name.name] = obj
        return ans

    def scan_for_local_vars(body):
        """
        Pick out all variables being assigned to from within this scope, we'll mark them as local

        body        body to be scanned
        """
        localvars = []
        seen = {}

        def push(x):
            if Object.prototype.hasOwnProperty.call(seen, x):
                return
            seen[x] = True
            localvars.push(x)

        def extend(arr):
            for x in arr:
                push(x)

        def scan_in_array(arr):
            for x in arr:
                if isinstance(x, AST_Seq):
                    x = x.to_array()
                    baselib_items['_$rapyd$_flatten'] = True
                elif isinstance(x, AST_Array):
                    x = x.elements
                    baselib_items['_$rapyd$_flatten'] = True
                if Array.isArray(x):
                    scan_in_array(x)
                else:
                    if not isinstance(x, AST_PropAccess):
                        push(x.name)


        if Array.isArray(body):
            # this is a body of statements
            for stmt in dir(body):
                # skip inner scopes
                if isinstance(body[stmt], AST_Scope):
                    continue

                # recursive descent into conditional, loop and exception bodies
                [ "body", "alternative" ].forEach(def(option):
                    opt = body[stmt][option]
                    if opt:
                        extend(scan_for_local_vars(opt))

                    if isinstance(opt, AST_Assign) and not (isinstance(opt.right, AST_Scope)):
                        extend(scan_for_local_vars(opt.right))
                )

                # pick up iterators from loops
                if isinstance(body[stmt], AST_ForIn):
                    if isinstance(body[stmt].init, AST_Array):
                        # iteration via implicit tuple
                        push("_$rapyd$_Unpack")
                        scan_in_array(body[stmt].init.elements)
                    else:
                        # iteration via a single variable
                        push(body[stmt].init.name)
                elif isinstance(body[stmt], AST_DWLoop):
                    extend(scan_for_local_vars(body[stmt]))
                elif isinstance(body[stmt], AST_If) \
                        and is_nested_comparison(body[stmt].condition):
                    # if statement condition with complex comparison
                    push("_$rapyd$_Temp")
                elif isinstance(body[stmt], AST_Exit) and is_nested_comparison(body[stmt].value):
                    # returning a nested conditional
                    push("_$rapyd$_Temp")

        elif body.body:
            # recursive descent into wrapper statements that contain body blocks
            extend(scan_for_local_vars(body.body))
            if body.alternative:
                extend(scan_for_local_vars(body.alternative))

        elif isinstance(body, AST_Assign):
            # this is a single assignment operator
            if isinstance(body.left, AST_Array):
                # assignment to an implicit tuple
                push("_$rapyd$_Unpack")
                scan_in_array(body.left.elements)
            elif body.left.name:
                # assignment to a single variable
                push(body.left.name)

            if is_nested_comparison(body.right):
                # assignment of nested conditional result to a variable
                push("_$rapyd$_Temp")
            elif isinstance(body.right, AST_Conditional) and is_nested_comparison(body.right.condition):
                # assignment of a ternary condition result that uses nested conditional
                push("_$rapyd$_Temp")

        elif isinstance(body, AST_Conditional) and is_nested_comparison(body.condition):
            # ternary condition that uses nested conditional and triggers other logic
            # this is basically a really ugly way to write an if/else
            push("_$rapyd$_Temp")

        elif is_nested_comparison(body):
            # statement itself is a stand-alone nested conditional - programmatically this would probably
            # be a useless statement
            push("_$rapyd$_Temp")

        return localvars

    def scan_for_nonlocal_defs(body):
        vars = []
        if Array.isArray(body):
            for stmt in dir(body):
                if isinstance(body[stmt], AST_Scope):
                    continue

                # don't invade nested scopes
                if isinstance(body[stmt], AST_Definitions):
                    body[stmt].definitions.forEach(def(vardef):
                        vars.push(vardef.name.name)
                    )

                [ "body", "alternative" ].forEach(def(option):
                    nonlocal vars
                    opt = body[stmt][option]
                    if opt:
                        vars = vars.concat(scan_for_nonlocal_defs(opt))

                )

        elif body.body:
            vars = vars.concat(scan_for_nonlocal_defs(body.body))
            if body.alternative:
                vars = vars.concat(scan_for_nonlocal_defs(body.alternative))


        return vars

    statement = embed_tokens(def():
        # From Kovid: The next three lines were a hack to try to support statements
        # starting with a regexp literal. However, it did not work, for example:
        # echo 'f=1\n/asd/.test()' | rs -> parse error
        # So we just accept that this cannot be supported in RS, and avoid hacks that mess
        # with the internal state of S. In any case,
        # statements starting with a literal are very rare.
        if S.token.type == 'operator' and S.token.value.substr(0, 1) == '/':
            token_error(S.token, 'RapydScript does not support statements starting with regexp literals')

        S.statement_starting_token = S.token
        tmp_ = S.token.type
        if tmp_ == "string":
            dir = S.in_directives
            stat = simple_statement()
            # XXXv2: decide how to fix directives
            if dir and isinstance(stat.body, AST_String) and not is_("punc", ","):
                return new AST_Directive({
                    'value': stat.body.value
                })

            return stat
        elif tmp_ == "shebang":
            tmp_ = S.token.value
            next()
            return new AST_Directive({
                'value': tmp_
            })
        elif tmp_ == "num" or tmp_ == "regexp" or tmp_ == "operator" or tmp_ == "atom":
            return simple_statement()
        elif tmp_ == "punc":
            tmp_ = S.token.value
            if tmp_ == ":":
                return new AST_BlockStatement({
                    'start': S.token,
                    'body': block_(),
                    'end': prev()
                })
            elif tmp_ == "{" or tmp_ == "[" or tmp_ == "(":
                return simple_statement()
            elif tmp_ == ";":
                next()
                return new AST_EmptyStatement({'stype':';', 'start':prev(), 'end':prev()})
            else:
                unexpected()
        elif tmp_ == "name":
            if (is_token(peek(), 'punc', ':')) token_error(peek(), 'invalid syntax, colon not allowed here')
            return simple_statement()
        elif tmp_ == "keyword":
            tmp_ = S.token.value
            next()
            if tmp_ == "break":
                return break_cont(AST_Break)
            elif tmp_ == "continue":
                return break_cont(AST_Continue)
            elif tmp_ == "debugger":
                semicolon()
                return new AST_Debugger()
            elif tmp_ == "do":
                return new AST_Do({
                    'body': in_loop(statement),
                    'condition': def():
                        expect(".")
                        expect_token("keyword", "while")
                        tmp = expression(True)
                        semicolon()
                        return tmp
                    .call(this)
                })
            elif tmp_ == "while":
                return new AST_While({
                    'condition': expression(True),
                    'body': in_loop(statement)
                })
            elif tmp_ == "for":
                if is_("name", "JS"):
                    return for_js()
                return for_()
            elif tmp_ == "from":
                return import_(True)
            elif tmp_ == "import":
                return import_(False)
            elif tmp_ == "class":
                baselib_items["extends"] = True
                if options.auto_bind:
                    baselib_items["rebind_all"] = True
                return class_()
            elif tmp_ == "def":
                start = prev()
                func = function_(S.in_class.slice(-1)[0])
                func.start = start
                func.end = prev()
                chain = subscripts(func, True)
                if chain == func:
                    return func
                else:
                    return new AST_SimpleStatement({
                        'start': start,
                        'body': chain,
                        'end': prev()
                    })
            elif tmp_ == "if":
                return if_()
            elif tmp_ == "pass":
                semicolon()
                return new AST_EmptyStatement({'stype':'pass', 'start':prev(), 'end':prev()})
            elif tmp_ == "return":
                if S.in_function == 0:
                    croak("'return' outside of function")
                if S.functions[-1].is_generator:
                    croak("'return' not allowed in a a function with yield")
                S.functions[-1].is_generator = False

                return new AST_Return({
                    'value': (is_("punc", ";") ?
                        def():
                            semicolon()
                            return None
                        .call(this) : (can_insert_semicolon() ? None
                            : def():
                                tmp = expression(True)
                                semicolon()
                                return tmp
                            .call(this)
                        )
                    )
                })
            elif tmp_ == "yield":
                return yield_()
            elif tmp_ == "switch":
                return new AST_Switch({
                    'expression': parenthesised(),
                    'body': in_loop(switch_body_)
                })
            elif tmp_ == "raise":
                if S.token.nlb:
                    return new AST_Throw({
                        'value': new AST_SymbolCatch({
                            'name': "_$rapyd$_Exception"
                        })
                    })

                tmp = expression(True)
                semicolon()
                return new AST_Throw({
                    'value': tmp
                })
            elif tmp_ == "try":
                return try_()
            elif tmp_ == "nonlocal":
                tmp = nonlocal_()
                semicolon()
                return tmp
            elif tmp_ == "const":
                tmp = const_()
                semicolon()
                return tmp
            elif tmp_ == "with":
                return new AST_With({
                    'expression': parenthesised(),
                    'body': statement()
                })
            else:
                unexpected()
    )

    def simple_statement(tmp):
        tmp = expression(True)
        semicolon()
        return new AST_SimpleStatement({
            'body': tmp
        })

    def break_cont(type):
        if S.in_loop == 0:
            croak(type.TYPE + " not inside a loop or switch")
        semicolon()
        return new type()

    def yield_():
        if S.in_function == 0:
            croak("'yield' outside of function")
        if S.functions[-1].is_generator == False:
            croak("'yield' not allowed in a function with return")
        S.functions[-1].is_generator = True
        is_yield_from = is_('keyword', 'from')
        if is_yield_from:
            next()
        return new AST_Yield({
            'is_yield_from':is_yield_from,
            'value': (is_("punc", ";") ?
                def():
                    semicolon()
                    return None
                .call(this) : (can_insert_semicolon() ? None
                    : def():
                        tmp = expression(True)
                        semicolon()
                        return tmp
                    .call(this)
                )
            )
        })

    def for_(list_comp):
        #        expect("(")
        init = None
        if not is_("punc", ";"):
            init = expression(True, True)
            # standardize AST_Seq into array now for consistency
            if isinstance(init, AST_Seq):
                if isinstance(init.car, AST_SymbolRef) and isinstance(init.cdr, AST_SymbolRef):
                    # Optimization to prevent runtime call to _$rapyd$_flatten when init is simply (a, b)
                    tmp = init.to_array()
                else:
                    tmp = [init]
                init = new AST_Array({
                    'start': init.start,
                    'elements': tmp,
                    'end': init.end
                })

            if is_("operator", "in"):
                if isinstance(init, AST_Var) and init.definitions.length > 1:
                    croak("Only one variable declaration allowed in for..in loop")
                next()
                return for_in(init, list_comp)

        unexpected()

    def for_in(init, list_comp):
        lhs = (isinstance(init, AST_Var) ? init.definitions[0].name : None)
        obj = expression(True)
        baselib_items["iterable"] = True
        #        expect(")")
        if list_comp:
            return {
                'init': init,
                'name': lhs,
                'object': obj
            }

        return new AST_ForIn({
            'init': init,
            'name': lhs,
            'object': obj,
            'body': in_loop(statement)
        })

    # A native JavaScript for loop - for JS("var i=0; i<5000; i++"):
    def for_js():
        condition = expression(True, True)
        return new AST_ForJS({
            'condition': condition,
            'body': in_loop(statement)
        })

    # scan function/class body for nested class declarations
    def get_class_in_scope(expr):
        # TODO: Currently if a local variable shadows a class name defined in
        # an outerscope, the logic below will identify that variable as a
        # class. This bug was always present. Fixing it will require the parser
        # to maintain a list of local variables for every AST_Scope and provide
        # an easy way to walk the ast tree upwards.
        if isinstance(expr, AST_SymbolRef):
            # check Native JS classes
            if NATIVE_CLASSES.hasOwnProperty(expr.name):
                return NATIVE_CLASSES[expr.name]
            if ERROR_CLASSES.hasOwnProperty(expr.name):
                return ERROR_CLASSES[expr.name]

            # traverse in reverse to check local variables first
            for s in range(S.classes.length-1, -1, -1):
                if S.classes[s].hasOwnProperty(expr.name):
                    return S.classes[s][expr.name]

        elif isinstance(expr, AST_Dot):
            referenced_path = []
            # this one is for detecting classes inside modules and eventually nested classes
            while isinstance(expr, AST_Dot):
                referenced_path.unshift(expr.property)
                expr = expr.expression
            if isinstance(expr, AST_SymbolRef):
                referenced_path.unshift(expr.name)
                # now 'referenced_path' should contain the full path of potential class
                if len(referenced_path) > 1:
                    class_name = referenced_path.join('.')
                    for s in range(S.classes.length-1, -1, -1):
                        if S.classes[s].hasOwnProperty(class_name):
                            return S.classes[s][class_name]
        return False

    def import_error(message):
        ctx = S.input.context()
        raise new ImportError(message, ctx.filename, ctx.tokline, ctx.tokcol, ctx.tokpos)

    def do_import(key):
        if IMPORTED.hasOwnProperty(key):
            return
        if IMPORTING.hasOwnProperty(key) and IMPORTING[key]:
            import_error('Detected a recursive import of: ' + key + ' while importing: ' + module_id)

        # Ensure that the package containing this module is also imported
        package_module_id = key.split('.')[:-1].join('.')
        if len(package_module_id) > 0:
            do_import(package_module_id)

        if options.for_linting:
            IMPORTED[key] = {'is_cached':True, 'classes':{}, 'module_id':key, 'exports':[],
                             'submodules':[], 'nonlocalvars':[], 'baselib':{}, 'outputs':{}}
            if len(package_module_id) > 0:
                IMPORTED[package_module_id].submodules.push(key)
            return

        def safe_read(base_path):
            for i, path in enumerate([base_path + '.pyj', base_path + '/__init__.pyj']):
                try:
                    return [readfile(path, "utf-8"), path]  # noqa:undef
                except as e:
                    if e.code == 'ENOENT' or e.code == 'EPERM' or e.code == 'EACCESS':
                        if i == 1:
                            return None, None
                    if i == 1:
                        raise

        src_code = filename = None
        modpath = key.replace('.', '/')

        for location in [options.basedir, options.libdir]:
            if location:
                data, filename = safe_read(location + '/' + modpath)
                if data is not None:
                    src_code = data
                    break
        if src_code is None:
            import_error("Failed Import: '" + key + "' module doesn't exist in either '" + options.basedir + "' or '" + options.libdir + "'")

        try:
            cached = JSON.parse(readfile(filename + '-cached', 'utf-8'))  # noqa:undef
        except:
            cached = None

        srchash = sha1sum(src_code)  # noqa:undef
        if cached and cached['version'] == COMPILER_VERSION and cached['signature'] == srchash:
            for ikey in cached.imported_module_ids:
                do_import(ikey)  # Ensure all modules imported by the cached module are also imported
            IMPORTED[key] = {
                'is_cached':True, 'classes':cached['classes'], 'outputs':cached['outputs'], 'module_id':key,
                'submodules':[], 'nonlocalvars':cached['nonlocalvars'], 'baselib':cached['baselib'], 'exports':cached.exports
            }
        else:
            parse(src_code, {
                'filename': filename,
                'toplevel': None,
                'basedir': options.basedir,
                'libdir': options.libdir,
                'module_id': key,
                'IMPORTED': IMPORTED,
                'IMPORTING': IMPORTING,
            })  # This function will add the module to IMPORTED itself

        IMPORTED[key].srchash = srchash
        if len(package_module_id) > 0:
            IMPORTED[package_module_id].submodules.push(key)

        for bitem in Object.keys(IMPORTED[key].baselib):
            baselib_items[bitem] = True
        imported_module_ids.push(key)


    import_ = def(from_import):
        ans = new AST_Imports({'imports':[]})
        while True:
            tok = tmp = name = last_tok = expression(False)
            key = ''
            while isinstance(tmp, AST_Dot):
                key = "." + tmp.property + key
                tmp = last_tok = tmp.expression
            key = tmp.name + key
            alias = None
            if not from_import and is_('keyword', 'as'):
                next()
                alias = as_symbol(AST_SymbolAlias)
            aimp = new AST_Import({
                'module': name,
                'key': key,
                'alias': alias,
                'argnames':None,
                'body':def():
                    return IMPORTED[key]
            })
            aimp.start, aimp.end = tok.start, last_tok.end
            ans.imports.push(aimp)
            if from_import:
                break
            if is_('punc', ','):
                next()
            else:
                break

        for imp in ans['imports']:
            do_import(imp.key)
            classes = IMPORTED[key].classes
            if from_import:
                expect_token("keyword", "import")
                imp.argnames = argnames = []
                bracketed = is_('punc', '(')
                if bracketed:
                    next()
                exports = {}
                for symdef in IMPORTED[key].exports:
                    exports[symdef.name] = True
                while True:
                    aname = as_symbol(AST_ImportedVar)
                    if not options.for_linting and not exports.hasOwnProperty(aname.name):
                        import_error('The symbol "' + aname.name + '" is not exported from the module: ' + key)
                    if is_('keyword', 'as'):
                        next()
                        aname.alias = as_symbol(AST_SymbolAlias)
                    argnames.push(aname)
                    if is_('punc', ','):
                        next()
                    else:
                        if bracketed:
                            if is_('punc', ')'):
                                next()
                            else:
                                continue
                        break

                # Put imported class names in the outermost scope
                for argvar in argnames:
                    obj = classes[argvar.name]
                    if obj:
                        key = (argvar.alias) ? argvar.alias.name : argvar.name
                        S.classes[-1][key] = { "static": obj.static, 'bound': obj.bound }
            else:
                for cname in Object.keys(classes):
                    obj = classes[cname]
                    key = (imp.alias) ? imp.alias.name : imp.key
                    S.classes[-1][key + '.' + obj.name.name] = { 'static': obj.static, 'bound': obj.bound }

        return ans

    class_ = def():
        name = as_symbol(AST_SymbolDefun)
        if not name:
            unexpected()

        # detect external classes
        externaldecorator = S.decorators.indexOf("external")
        if externaldecorator != -1:
            S.decorators.splice(externaldecorator, 1)

        class_details = {
            "static": [],
            'bound': {}
        }
        definition = new AST_Class({
            'name': name,
            'module_id':module_id,
            'parent': def():
                if is_("punc", "("):
                    S.in_parenthesized_expr = True
                    next()
                    a = expr_atom(False)
                    expect(")")
                    S.in_parenthesized_expr = False
                    return a
                else:
                    return None
            .call(this),
            'localvars': [],
            "static": class_details.static,
            'external': externaldecorator != -1,
            'bound': class_details.bound,
            'statements': [],
            'decorators': def():
                d = []
                S.decorators.forEach(def(decorator):
                    d.push(new AST_Decorator({
                        'name': decorator
                    }))
                )
                S.decorators = []
                return d
            .call(this),
            'body': def(loop, labels):
                # navigate to correct location in the module tree and append the class
                S.in_class.push(name.name)
                S.classes[S.classes.length - 1][name.name] = class_details
                S.classes.push({})
                S.in_function += 1
                S.in_directives = True
                S.in_loop = 0
                S.labels = []
                a = block_()
                S.in_function -= 1
                S.classes.pop()
                S.in_class.pop()
                S.in_loop = loop
                S.labels = labels
                return a
            .call(this, S.in_loop, S.labels)
        })
        # find the constructor
        for i in dir(definition.body):
            stmt = definition.body[i]
            if isinstance(stmt, AST_Method) and stmt.name.name == "__init__":
                definition.init = stmt
                break
        # find the class variables
        class_var_names = {}
        # Ensure that if a class variable refers to another class variable in
        # its initialization, the referenced variables' names is correctly
        # mangled.
        def walker():
            this._visit = def(node, descend):
                if isinstance(node, AST_Method):
                    class_var_names[node.name.name] = True
                    return
                elif isinstance(node, AST_Assign) and isinstance(node.left, AST_SymbolRef):
                    class_var_names[node.left.name] = True
                elif isinstance(node, AST_SymbolRef) and Object.prototype.hasOwnProperty.call(class_var_names, node.name):
                    node.thedef = new AST_SymbolDefun({'name':name.name + '.prototype.' + node.name})
                if descend:
                    descend.call(node)
        visitor = new walker()

        for i in dir(definition.body):
            stmt = definition.body[i]
            if not isinstance(stmt, AST_Class):
                stmt.walk(visitor)
                definition.statements.push(stmt)
        return definition

    function_ = def(in_class, ctor):
        is_accessor = ctor is AST_Accessor
        name = (is_("name") ? as_symbol((in_class ? AST_SymbolDefun : (is_accessor ? AST_SymbolAccessor : AST_SymbolLambda))) : (is_accessor and (is_("string") or is_("num")) ? as_atom_node() : None))
        if in_class and not name:
            unexpected()

        staticmethod = False
        if in_class:
            staticloc = S.decorators.indexOf("staticmethod")
            if staticloc != -1:
                S.decorators.splice(staticloc, 1)
                S.classes[S.classes.length - 2][in_class].static.push(name.name)
                staticmethod = True
            elif name.name != "__init__" and options.auto_bind:
                baselib_items["bind"] = True
                S.classes[S.classes.length - 2][in_class].bound[name.name] = True

        expect("(")
        S.in_parenthesized_expr = True
        if not ctor:
            ctor = in_class ? AST_Method : AST_Function

        is_generator = []
        definition = new ctor({
            'name': name,
            'argnames': def(a):
                defaults = {}
                first = True
                seen_names = {}

                def get_arg():
                    if Object.prototype.hasOwnProperty.call(seen_names, S.token.value):
                        token_error(prev(), "Can't repeat parameter names")
                    if S.token.value == 'arguments':
                        token_error(prev(), "Can't use the name arguments as a parameter name, it is reserved by JavaScript")
                    seen_names[S.token.value] = True
                    return as_symbol(AST_SymbolFunarg)

                while not is_("punc", ")"):
                    if first:
                        first = False
                    else:
                        expect(",")
                    if is_('operator', '**'):
                        # **kwargs
                        next()
                        if a.kwargs:
                            token_error(prev(), "Can't define multiple **kwargs in function definition")
                        a.kwargs = get_arg()
                    elif is_('operator', '*'):
                        # *args
                        next()
                        if a.starargs:
                            token_error(prev(), "Can't define multiple *args in function definition")
                        if a.kwargs:
                            token_error(prev(), "Can't define *args after **kwargs in function definition")
                        a.starargs = get_arg()
                    else:
                        if a.starargs or a.kwargs:
                            token_error(prev(), "Can't define a formal parameter after *args or **kwargs")
                        a.push(get_arg())
                        if is_("operator", "="):
                            if a.kwargs:
                                token_error(prev(), "Can't define an optional formal parameter after **kwargs")
                            val = prev().value
                            next()
                            defaults[val] = expression(False)
                            a.has_defaults = True
                        else:
                            if a.has_defaults:
                                token_error(prev(), "Can't define required formal parameters after optional formal parameters")

                next()
                S.in_parenthesized_expr = False
                a.defaults = defaults
                a.is_simple_func = not a.starargs and not a.kwargs and not a.has_defaults
                return a
            .call(this, []),
            'localvars': [],
            'decorators': def():
                d = []
                S.decorators.forEach(def(decorator):
                    d.push(new AST_Decorator({
                        'name': decorator
                    }))
                )
                S.decorators = []
                return d
            .call(this),
            'body': def(loop, labels):
                S.in_class.push(False)
                S.classes.push({})
                S.in_function += 1
                S.functions.push({})
                S.in_directives = True
                S.in_loop = 0
                S.labels = []
                a = block_()
                S.in_function -= 1
                is_generator.push(bool(S.functions.pop().is_generator))
                S.classes.pop()
                S.in_class.pop()
                S.in_loop = loop
                S.labels = labels
                return a
            .call(this, S.in_loop, S.labels)
        })
        definition.is_generator = is_generator[0]
        if isinstance(definition, AST_Method):
            definition.static = staticmethod
            if definition.is_generator and definition.name and definition.name.name == '__init__':
                croak('The __init__ method of a class cannot be a generator (yield not allowed)')
        if definition.is_generator:
            baselib_items['yield'] = True

        # detect local variables, strip function arguments
        assignments = scan_for_local_vars(definition.body)
        for i in range(assignments.length):
            for j in range(definition.argnames.length+1):
                if j == definition.argnames.length:
                    definition.localvars.push(new_symbol(AST_SymbolVar, assignments[i]))
                elif j < definition.argnames.length and assignments[i] == definition.argnames[j].name:
                    break

        nonlocals = scan_for_nonlocal_defs(definition.body)
        nonlocals.forEach(def(variable):
            for i in dir(definition.localvars).reverse():
                if definition.localvars[i].name == variable:
                    definition.localvars.splice(i, 1)
        )
        return definition

    def if_():
        cond = expression(True)
        body = statement()
        belse = None
        if is_("keyword", "elif") or is_("keyword", "else"):
            if is_("keyword", "else"):
                next()
            else:
                S.token.value = "if"
            # effectively converts 'elif' to 'else if'
            belse = statement()

        return new AST_If({
            'condition': cond,
            'body': body,
            'alternative': belse
        })

    def block_():
        expect(":")
        a = []
        if not S.token.nlb:
            while not S.token.nlb:
                if is_("eof"):
                    unexpected()
                a.push(statement())
        else:
            while not is_("punc", "}"):
                if is_("eof"):
                    # end of file, terminate block automatically
                    return a
                a.push(statement())
            next()
        return a

    def switch_body_():
        expect("{")
        a = []
        cur = None
        branch = None

        while not is_("punc", "}"):
            if is_("eof"):
                unexpected()

            if is_("keyword", "case"):
                if branch:
                    branch.end = prev()

                cur = []
                branch = new AST_Case({
                    'start': (tmp = S.token, next(), tmp),
                    'expression': expression(True),
                    'body': cur
                })
                a.push(branch)
                expect(":")
            elif is_("keyword", "default"):
                if branch:
                    branch.end = prev()

                cur = []
                branch = new AST_Default({
                    'start': (tmp = S.token, next(), expect(":"), tmp),
                    'body': cur
                })
                a.push(branch)
            else:
                if not cur:
                    unexpected()
                cur.push(statement())

        if branch:
            branch.end = prev()
        next()
        return a

    def try_():
        body = block_()
        bcatch = []
        bfinally = None
        while is_("keyword", "except"):
            start = S.token
            next()
            exceptions = []
            if not is_("punc", ":") and not is_("keyword", "as"):
                exceptions.push(as_symbol(AST_SymbolVar))
                while is_("punc", ","):
                    next()
                    exceptions.push(as_symbol(AST_SymbolVar))

            name = None
            if is_("keyword", "as"):
                next()
                name = as_symbol(AST_SymbolCatch)

            bcatch.push(new AST_Except({
                'start': start,
                'argname': name,
                'errors': exceptions,
                'body': block_(),
                'end': prev()
            }))

        if is_("keyword", "finally"):
            start = S.token
            next()
            bfinally = new AST_Finally({
                'start': start,
                'body': block_(),
                'end': prev()
            })

        if not bcatch.length and not bfinally:
            croak("Missing except/finally blocks")

        return new AST_Try({
            'body': body,
            'bcatch': (bcatch.length ? new AST_Catch({
                'body': bcatch
            }) : None),
            'bfinally': bfinally
        })

    def vardefs(no_in, in_const, in_nonlocal):
        a = []
        while True:
            a.push(new AST_VarDef({
                'start': S.token,
                'name': as_symbol((in_const ? AST_SymbolConst : ((in_nonlocal) ? AST_SymbolNonlocal : AST_SymbolVar))),
                'value': (is_("operator", "=") ? (next(), expression(False, no_in)) : None),
                'end': prev()
            }))
            if not is_("punc", ","):
                break
            next()

        return a

    nonlocal_ = def(no_in):
        return new AST_Var({
            'start': prev(),
            'definitions': vardefs(no_in, False, True),
            'end': prev()
        })

    const_ = def():
        return new AST_Const({
            'start': prev(),
            'definitions': vardefs(False, True),
            'end': prev()
        })

    new_ = def():
        start = S.token
        expect_token("operator", "new")
        newexp = expr_atom(False)

        if is_("punc", "("):
            S.in_parenthesized_expr = True
            next()
            args = expr_list(")")
            S.in_parenthesized_expr = False
        else:
            args = []

        return subscripts(new AST_New({
            'start': start,
            'expression': newexp,
            'args': args,
            'end': prev()
        }), True)

    def token_as_atom_node(tok):
        tmp_ = tok.type
        if tmp_ == "name":
            return token_as_symbol(tok, AST_SymbolRef)
        elif tmp_ == "num":
            return new AST_Number({
                'start': tok,
                'end': tok,
                'value': tok.value
            })
        elif tmp_ == "string":
            return new AST_String({
                'start': tok,
                'end': tok,
                'value': tok.value
            })
        elif tmp_ == "regexp":
            return new AST_RegExp({
                'start': tok,
                'end': tok,
                'value': tok.value
            })
        elif tmp_ == "atom":
            tmp__ = tok.value
            if tmp__ == "False":
                return new AST_False({
                    'start': tok,
                    'end': tok
                })
            elif tmp__ == "True":
                return new AST_True({
                    'start': tok,
                    'end': tok
                })
            elif tmp__ == "None":
                return new AST_Null({
                    'start': tok,
                    'end': tok
                })
        token_error(tok, 'Expecting an atomic token (number/string/bool/regexp/None)')

    def as_atom_node():
        ret = token_as_atom_node(S.token)
        next()
        return ret

    expr_atom = def(allow_calls):
        if is_("operator", "new"):
            return new_()

        start = S.token
        if is_("punc"):
            tmp_ = start.value
            if tmp_ == "(":
                S.in_parenthesized_expr = True
                next()
                if is_('punc', ')'):
                    next()
                    return new AST_Array({'elements':[]})
                ex = expression(True)
                ex.start = start
                ex.end = S.token
                if isinstance(ex, AST_SymbolRef):
                    ex.parens = True
                expect(")")
                S.in_parenthesized_expr = False
                return subscripts(ex, allow_calls)
            elif tmp_ == "[":
                return subscripts(array_(), allow_calls)
            elif tmp_ == "{":
                return subscripts(object_(), allow_calls)

            unexpected()

        if is_("keyword", "class"):
            next()
            cls = class_()
            cls.start = start
            cls.end = prev()
            return subscripts(cls, allow_calls)

        if is_("keyword", "def"):
            next()
            func = function_(False)
            func.start = start
            func.end = prev()
            return subscripts(func, allow_calls)

        if is_('keyword', 'yield'):
            next()
            return yield_()

        if ATOMIC_START_TOKEN[S.token.type]:
            return subscripts(as_atom_node(), allow_calls)

        unexpected()

    def expr_list(closing, allow_trailing_comma, allow_empty, func_call):
        first = True
        a = []
        saw_starargs = False
        while not is_("punc", closing):
            if saw_starargs:
                token_error(prev(), "*args must be the last argument in a function call")

            if first:
                first = False
            else:
                expect(",")
            if allow_trailing_comma and is_("punc", closing):
                break

            if is_("operator", "*") and func_call:
                saw_starargs = True
                next()

            if is_("punc", ",") and allow_empty:
                a.push(new AST_Hole({
                    'start': S.token,
                    'end': S.token
                }))
            else:
                a.push(expression(False))

        if func_call:
            tmp = []
            tmp.kwargs = []
            for arg in a:
                if isinstance(arg, AST_Assign):
                    tmp.kwargs.push([arg.left, arg.right])
                else:
                    tmp.push(arg)
            a = tmp

        next()
        if saw_starargs:
            a.starargs = True
        return a

    def func_call_list():
        a = []
        first = True
        a.kwargs = []
        a.kwarg_items = kwargs = []
        a.starargs = False
        while not is_("punc", ')'):
            if first:
                first = False
            else:
                expect(",")
            if is_('operator', '*'):
                next()
                arg = expression(False)
                arg.is_array = True
                a.push(arg)
                a.starargs = True
            elif is_('operator', '**'):
                next()
                kwargs.push(as_symbol(AST_SymbolVar, False))
                a.starargs = True
            else:
                arg = expression(False)
                if isinstance(arg, AST_Assign):
                    a.kwargs.push([arg.left, arg.right])
                else:
                    a.push(arg)
        if a.kwargs.length:
            baselib_items['_$rapyd$_desugar_kwargs()'] = True
        next()
        return a

    array_ = embed_tokens(def():
        expect("[")
        expr = []
        if not is_("punc", "]"):
            expr.push(expression(False))
            if is_("keyword", "for"):
                # list comprehension
                return read_comprehension(new AST_ListComprehension({'statement': expr[0]}))

            if is_("operator", "til"):
                # up to but not including upper limit
                baselib_items['range'] = True
                next()
                expr.push(expression(False))
                ret = subscripts(new AST_Call({
                    'start': S.token,
                    'expression': new AST_SymbolRef({
                        'name': "range"
                    }),
                    'args': expr,
                    'end': prev()
                }), True)
                expect("]")
                return ret
            elif is_("operator", "to"):
                # now add a tiny number to make sure we include the upper limit
                baselib_items['range'] = True
                next()
                expr.push(new AST_Binary({
                    'left': expression(False),
                    'operator': "+",
                    'right': new AST_Number({
                        'value': 0.000001
                    })
                }))
                ret = subscripts(new AST_Call({
                    'start': S.token,
                    'expression': new AST_SymbolRef({
                        'name': "range"
                    }),
                    'args': expr,
                    'end': prev()
                }), True)
                expect("]")
                return ret
            elif not is_("punc", "]"):
                expect(",")

        return new AST_Array({
            'elements': expr.concat(expr_list("]", not options.strict, True))
        })
    )

    object_ = embed_tokens(def():
        expect("{")
        first = True
        has_non_const_keys = False
        a = []
        while not is_("punc", "}"):
            if not first:
                expect(",")
            if not options.strict and is_("punc", "}"):
                # allow trailing comma
                break
            first = False

            start = S.token
            left = expression(False)
            if is_('keyword', 'for'):
                return read_comprehension(new AST_SetComprehension({'statement':left}))
            if is_('punc', ','):
                end = prev()
                return set_(start, end, left)
            if not isinstance(left, AST_Constant):
                has_non_const_keys = True
            expect(":")
            a.push(new AST_ObjectKeyVal({
                'start': start,
                'key': left,
                'value': expression(False),
                'end': prev()
            }))
            if a.length == 1 and is_('keyword', 'for'):
                return dict_comprehension(a)

        next()
        return new (has_non_const_keys ? AST_ExpressiveObject : AST_Object)({
            'properties': a
        })
    )

    def set_(start, end, expr):
        ostart = start
        a = [new AST_SetItem({'start':start, 'end':end, 'value':expr})]
        while not is_("punc", "}"):
            expect(",")
            start = S.token
            if not options.strict and is_("punc", "}"):
                # allow trailing comma
                break
            a.push(new AST_SetItem({'start':start, 'value':expression(False), 'end':prev()}))
        next()
        return new AST_Set({'items':a, 'start':ostart, 'end':prev()})

    def read_comprehension(obj, terminator):
        S.in_comprehension = True
        S.in_parenthesized_expr = False  # in case we are already in a parenthesized expression
        expect_token('keyword', 'for')
        forloop = for_(True)
        baselib_items["iterable"] = True
        obj.init = forloop.init
        obj.name = forloop.name
        obj.object = forloop.object
        obj.condition = (is_("punc", terminator) ? None : (expect_token("keyword", "if"), expression(True)))
        expect(terminator)
        S.in_comprehension = False
        return obj

    def dict_comprehension(a):
        if a.length:
            left, right = a[0].key, a[0].value
        else:
            left = expression(False)
            if not is_('punc', ':'):
                return read_comprehension(new AST_SetComprehension({'statement':left}))
            expect(':')
            right = expression(False)
        return read_comprehension(new AST_DictComprehension({'statement':left, 'value_statement':right}))

    def as_name():
        tmp = S.token
        next()
        tmp_ = tmp.type
        if tmp_ == "name" or tmp_ == "operator" or tmp_ == "keyword" or tmp_ == "atom":
            return tmp.value
        else:
            unexpected()

    def token_as_symbol(tok, ttype):
        name = tok.value
        return new ((name == "this" ? AST_This : ttype))({
            'name': JS("String(tok.value)"),
            'start': tok,
            'end': tok
        })

    def as_symbol(ttype, noerror):
        if not is_("name"):
            if not noerror:
                croak("Name expected")
            return None

        sym = token_as_symbol(S.token, ttype)
        next()
        return sym

    # for generating/inserting a new symbol
    def new_symbol(type, name):
        sym = new ((name == "this" ? AST_This : type))({
            'name': JS("String(name)"),
            'start': None,
            'end': None
        })
        return sym

    def is_static_method(cls, method):
        if COMMON_STATIC.indexOf(method) != -1 or cls.static and cls.static.indexOf(method) != -1:
            return True
        else:
            return False

    subscripts = def(expr, allow_calls):
        start = expr.start
        if is_("punc", "."):
            next()
            return subscripts(new AST_Dot({
                'start': start,
                'expression': expr,
                'property': as_name(),
                'end': prev()
            }), allow_calls)

        if is_("punc", "[") and not S.token.nlb:
            next()
            slice_bounds = []
            is_slice = False
            if is_("punc", ":"):
                # slice [:n]
                slice_bounds.push(None)
            else:
                slice_bounds.push(expression(False))

            if is_("punc", ":"):
                # slice [n:m?]
                is_slice = True
                next()
                if is_("punc", ":"):
                    slice_bounds.push(None)
                elif not is_("punc", "]"):
                    slice_bounds.push(expression(False))

            if is_("punc", ":"):
                # slice [n:m:o?]
                baselib_items["eslice"] = True
                next()
                if is_("punc", "]"):
                    unexpected()
                else:
                    slice_bounds.push(expression(False))

            expect("]")

            if is_slice:
                if is_("operator") and S.token.value == "=":
                    # splice-assignment (arr[start:end] = ...)
                    next()  # swallow the assignment
                    return subscripts(new AST_Splice({
                        'start': start,
                        'expression': expr,
                        'property': slice_bounds[0] or new AST_Number({
                            'value': 0
                        }),
                        'property2': slice_bounds[1],
                        'assignment': expression(True),
                        'end': prev()
                    }), allow_calls)
                elif slice_bounds.length == 3:
                    # extended slice (arr[start:end:step])
                    slice_bounds.unshift(slice_bounds.pop())
                    if not slice_bounds[-1]:
                        slice_bounds.pop()
                        if not slice_bounds[-1]:
                            slice_bounds.pop()
                    elif not slice_bounds[-2]:
                        slice_bounds[-2] = new AST_Undefined()

                    return subscripts(new AST_Call({
                        'start': start,
                        'expression': new AST_SymbolRef({
                            'name': "eslice"
                        }),
                        'args': [expr].concat(slice_bounds),
                        'end': prev()
                    }), allow_calls)
                else:
                    # regular slice (arr[start:end])
                    slice_bounds = [i == None ? new AST_Number({
                        'value': 0
                    }) : i for i in slice_bounds]
                    return subscripts(new AST_Call({
                        'start': start,
                        'expression': new AST_Dot({
                            'start': start,
                            'expression': expr,
                            'property': "slice",
                            'end': prev()
                        }),
                        'args': slice_bounds,
                        'end': prev()
                    }), allow_calls)
            else:
                # regular index (arr[index])
                return subscripts(new AST_Sub({
                    'start': start,
                    'expression': expr,
                    'property': slice_bounds[0] or new AST_Number({
                        'value': 0
                    }),
                    'end': prev()
                }), allow_calls)

        if allow_calls and is_("punc", "(") and not S.token.nlb:
            S.in_parenthesized_expr = True
            next()
            if isinstance(expr, AST_SymbolRef) and expr.name == "JS":
                # raw JavaScript chunk of code
                str_ = expression(False)
                if not (isinstance(str_, AST_String)):
                    token_error(prev(), "Compile-time function JS() can't process variables or expressions")

                ret = new AST_Verbatim({
                    'start': start,
                    'value': str_.value,
                    'end': prev()
                })
                expect(")")
                S.in_parenthesized_expr = False
                return subscripts(ret, True)
            elif not expr.parens and get_class_in_scope(expr):
                # this is an object being created using a class
                ret = subscripts(new AST_New({
                    'start': start,
                    'expression': expr,
                    'args': func_call_list(),
                    'end': prev()
                }), True)
                S.in_parenthesized_expr = False
                return ret
            else:
                if isinstance(expr, AST_Dot):
                    c = get_class_in_scope(expr.expression)

                if c:
                    # generate class call
                    funcname = expr
                    if funcname.property == "__init__":
                        funcname.property = "constructor"

                    ret = subscripts(new AST_ClassCall({
                        'start': start,
                        "class": expr.expression,
                        'method': funcname.property,
                        "static": is_static_method(c, funcname.property),
                        'args': func_call_list(),
                        'end': prev()
                    }), True)
                    S.in_parenthesized_expr = False
                    return ret
                elif isinstance(expr, AST_SymbolRef):
                    tmp_ = expr.name
                    # special functions that trigger addition of extra logic to generated JavaScript
                    if tmp_ == "bind"
                    or tmp_ == "rebind_all"
                    or tmp_ == "dir"
                    or tmp_ == "enumerate"
                    or tmp_ == "mixin"
                    or tmp_ == "print"
                    or tmp_ == "range"
                    or tmp_ == "reversed"
                    or tmp_ == "getattr"
                    or tmp_ == "setattr"
                    or tmp_ == "hasattr"
                    or tmp_ == 'iter'
                    or tmp_ == 'list':
                        baselib_items[tmp_] = True
                        # NOTE: there is intentionally no return here, we want these functions to go through regular logic
                        # after they trigger the appropriate baselib flag
                    elif tmp_ == "type":
                        ret = new AST_UnaryPrefix({
                            'start': start,
                            'operator': "typeof",
                            'expression': func_call_list()[0],
                            'end': prev()
                        })
                        S.in_parenthesized_expr = False
                        return ret
                    elif tmp_ == "isinstance":
                        args = func_call_list()
                        if args.length != 2:
                            croak('isinstance() must be called with exactly two arguments')
                        ret = new AST_Binary({
                            'start': start,
                            'left': args[0],
                            'operator': 'instanceof',
                            'right': args[1],
                            'end': prev()
                        })
                        S.in_parenthesized_expr = False
                        return ret
                    elif tmp_ == 'len'
                    or tmp_ == 'abs'
                    or tmp_ == 'max'
                    or tmp_ == 'min':
                        baselib_items[tmp_ + '()'] = True
                    elif tmp_ == "sum"
                    or tmp_ == "map"
                    or tmp_ == "zip"
                    or tmp_ == "filter":
                        baselib_items['itertools'] = True

                # fall-through to basic function call
                ret = subscripts(new AST_Call({
                    'start': start,
                    'expression': expr,
                    'args': func_call_list(),
                    'end': prev()
                }), True)
                S.in_parenthesized_expr = False
                return ret

        return expr

    maybe_unary = def(allow_calls):
        start = S.token
        if is_("operator") and UNARY_PREFIX(start.value):
            next()
            if start.value == "@":
                if is_("name") and (peek().value == "@" or peek().value == "def" or peek().value == "class"):
                    S.decorators.push(S.token.value)
                    next()
                    return new AST_EmptyStatement({'stype':'@', 'start':prev(), 'end':prev()})
                else:
                    unexpected()

            ex = make_unary(AST_UnaryPrefix, start.value, maybe_unary(allow_calls))
            ex.start = start
            ex.end = prev()
            return ex

        val = expr_atom(allow_calls)
        while is_("operator") and UNARY_POSTFIX(S.token.value) and not S.token.nlb:
            val = make_unary(AST_UnaryPostfix, S.token.value, val)
            val.start = start
            val.end = S.token
            next()
        return val

    def make_unary(ctor, op, expr):
        return new ctor({
            'operator': op,
            'expression': expr
        })

    expr_op = def(left, min_prec, no_in):
        op = (is_("operator") ? S.token.value : None)
        not_in = False
        if op == "!" and peek().type == "operator" and peek().value == "in":
            next()
            op = "in"
            not_in = True

        if op == "in":
            if no_in:
                op = None
            else:
                baselib_items['_$rapyd$_in()'] = True

        prec = (op != None ? PRECEDENCE[op] : None)
        if prec != None and prec > min_prec:
            next()
            right = expr_op(maybe_unary(True), prec, no_in)
            ret = new AST_Binary({
                'start': left.start,
                'left': left,
                'operator': op,
                'right': right,
                'end': right.end
            })
            if not_in:
                ret = new AST_UnaryPrefix({
                    'start': left.start,
                    'operator': "!",
                    'expression': ret,
                    'end': right.end
                })
            return expr_op(ret, min_prec, no_in)
        return left

    def expr_ops(no_in):
        return expr_op(maybe_unary(True), 0, no_in)

    maybe_conditional = def(no_in):
        start = S.token
        expr = expr_ops(no_in)
        if is_("operator", "?") or (is_('keyword', 'if') and (S.in_parenthesized_expr or (S.statement_starting_token != S.token and !S.in_comprehension and !S.token.nlb))):
            pystyle = is_('keyword', 'if')
            next()
            ne = expression(False)
            if pystyle:
                expect_token('keyword', 'else')
                conditional = new AST_Conditional({
                    'start': start,
                    'condition': ne,
                    'consequent': expr,
                    'alternative': expression(False, no_in),
                    'end': peek()
                })
            else:
                yes = ne
                expect(":")
                conditional = new AST_Conditional({
                    'start': start,
                    'condition': expr,
                    'consequent': yes,
                    'alternative': expression(False, no_in),
                    'end': peek()
                })
            return conditional
        return expr

    def is_assignable(expr):
        if not options.strict:
            return True

        tmp_ = expr[0] + ""
        if tmp_ == "dot" or tmp_ == "sub" or tmp_ == "new" or tmp_ == "call":
            return True
        elif tmp_ == "name":
            return expr[1] != "this"

    maybe_assign = def(no_in):
        start = S.token
        left = maybe_conditional(no_in)
        val = S.token.value
        if is_("operator") and ASSIGNMENT(val):
            if is_assignable(left):
                next()
                return new AST_Assign({
                    'start': start,
                    'left': left,
                    'operator': val,
                    'right': maybe_assign(no_in),
                    'end': prev()
                })
            croak("Invalid assignment")
        return left

    expression = def(commas, no_in):
        # if there is an assignment, we want the sequences to pivot
        # around it to allow for tuple packing/unpacking
        start = S.token
        expr = maybe_assign(no_in)
        def build_seq(a):
            if a.length == 1:
                return a[0]

            return new AST_Seq({
                'start': start,
                'car': a.shift(),
                'cdr': build_seq(a),
                'end': peek()
            })
        if commas:
            left = [ expr ]
            while is_("punc", ",") and not peek().nlb:
                next()
                if isinstance(expr, AST_Assign):
                    left[left.length - 1] = left.slice(-1)[0].left
                    return new AST_Assign({
                        'start': start,
                        'left': (left.length == 1 ? left[0] : new AST_Array({
                            'elements': left
                        })),
                        'operator': expr.operator,
                        'right': new AST_Seq({
                            'car': expr.right,
                            'cdr': expression(True, no_in)
                        }),
                        'end': peek()
                    })

                expr = maybe_assign(no_in)
                left.push(expr)

            # if last one was an assignment, fix it
            if left.length > 1 and isinstance(left.slice(-1)[0], AST_Assign):
                left[left.length - 1] = left.slice(-1)[0].left
                return new AST_Assign({
                    'start': start,
                    'left': new AST_Array({
                        'elements': left
                    }),
                    'operator': expr.operator,
                    'right': expr.right,
                    'end': peek()
                })

            return build_seq.call(this, left)
        return expr

    def in_loop(cont):
        S.in_loop += 1
        ret = cont()
        S.in_loop -= 1
        return ret

    return def():
        start = S.token
        body = []
        first_token = True
        while not is_("eof"):
            element = statement()
            if first_token and isinstance(element, AST_Directive) and element.value.indexOf('#!') == 0:
                shebang = element.value
            else:
                body.push(element)
            first_token = False

        end = prev()
        toplevel = options.toplevel
        if toplevel:
            toplevel.body = toplevel.body.concat(body)
            toplevel.end = end
        else:
            toplevel = new AST_Toplevel({
                'start': start,
                'body': body,
                'strict': def():
                    for stmt in body:
                        if isinstance(stmt, AST_Directive) and stmt.value == 'use strict':
                            return True
                    return False
                .call(this),
                'shebang': shebang,
                'end': end
            })

        def uniq(element, index, arr):
            return arr.lastIndexOf(element) == index

        toplevel.nonlocalvars = scan_for_nonlocal_defs(toplevel.body)
        assignments = scan_for_local_vars(toplevel.body)
        callables = scan_for_top_level_callables(toplevel.body).filter(uniq)
        toplevel.localvars = []
        assignments.forEach(def(item):
            if (toplevel.nonlocalvars.indexOf(item) < 0):
                toplevel.localvars.push(new_symbol(AST_SymbolVar, item))
        )
        toplevel.exports = toplevel.localvars.concat(callables).filter(uniq)
        toplevel.filename = options.filename
        toplevel.submodules = []
        toplevel.imported_module_ids = imported_module_ids
        toplevel.classes = scan_for_classes(toplevel.body)
        toplevel.import_order = Object.keys(IMPORTED).length
        toplevel.module_id = module_id
        IMPORTED[module_id] = toplevel
        toplevel.imports = IMPORTED
        toplevel.baselib = baselib_items
        IMPORTING[module_id] = False
        return toplevel
    .call(this)


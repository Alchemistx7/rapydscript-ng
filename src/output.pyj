# vim:fileencoding=utf-8
# License: BSD

# globals:console,regenerate,writefile

from utils import make_predicate, defaults, repeat_string, noop
from tokenizer import is_identifier_char
from parse import COMPILER_VERSION, PRECEDENCE
from ast import (
AST_Array, AST_Assign, AST_BaseCall, AST_Binary, AST_BlockStatement, AST_Break,
AST_Catch, AST_Class, AST_ClassCall, AST_Conditional, AST_Const,
AST_Constant, AST_Continue, AST_Debugger, AST_Definitions,
AST_Directive, AST_Do, AST_Dot, AST_EmptyStatement, AST_Except, AST_Exit,
AST_ExpressiveObject, AST_Finally, AST_ForIn, AST_ForJS, AST_Function,
AST_Hole, AST_If, AST_Imports, AST_Infinity, AST_Jump, AST_Lambda,
AST_ListComprehension, AST_LoopControl, AST_Method, AST_NaN, AST_New, AST_Node,
AST_Number, AST_Object, AST_ObjectKeyVal, AST_ObjectProperty, AST_PropAccess,
AST_RegExp, AST_Return, AST_Scope, AST_Set, AST_Seq, AST_SimpleStatement, AST_Splice,
AST_Statement, AST_StatementWithBody, AST_String, AST_Sub, AST_ItemAccess,
AST_Symbol, AST_SymbolRef, AST_This, AST_Throw, AST_Toplevel,
AST_Try, AST_Unary, AST_UnaryPostfix, AST_UnaryPrefix, AST_Undefined, AST_Var,
AST_VarDef, AST_Verbatim, AST_While, AST_With, AST_Yield, TreeWalker
)

DANGEROUS = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g

def OutputStream(options):
    options = defaults(options, {
        'indent_start': 0,
        'indent_level': 4,
        'quote_keys': False,
        'space_colon': True,
        'ascii_only': False,
        'width': 80,
        'max_line_len': 32000,
        'ie_proof': True,
        'beautify': False,
        'source_map': None,
        'bracketize': False,
        'semicolons': True,
        'comments': False,
        'preserve_line': False,
        'omit_baselib': False,
        'baselib': None,
        'private_scope': True,
        'auto_bind': False,
        'js_version':5,
        'write_name': True
    }, True)
    indentation = 0
    current_col = 0
    current_line = 1
    current_pos = 0
    OUTPUT = ""
    IMPORTED = {}
    def to_ascii(str_, identifier):
        return str_.replace(/[\u0080-\uffff]/g, def(ch):
            code = ch.charCodeAt(0).toString(16)
            if code.length <= 2 and not identifier:
                while code.length < 2:
                    code = "0" + code

                return "\\x" + code
            else:
                while code.length < 4:
                    code = "0" + code

                return "\\u" + code

        )

    def encode_string(str_):
        return JSON.stringify(str_).replace(DANGEROUS, def(a):
                return '\\u' + a.charCodeAt(0).toString(16)
        )

    def make_name(name):
        name = name.toString()
        if options.ascii_only:
            name = to_ascii(name, True)

        return name

    def make_indent(back):
        return repeat_string(" ", options.indent_start + indentation - back * options.indent_level)

    # -----[ beautification/minification ]-----
    might_need_space = False
    might_need_semicolon = False
    last = None
    def last_char():
        return last.charAt(last.length - 1)

    def maybe_newline():
        if options.max_line_len and current_col > options.max_line_len:
            print_("\n")


    requireSemicolonChars = make_predicate("( [ + * / - , .")
    def print_(str_):
        nonlocal might_need_space, might_need_semicolon, last, current_line, current_pos, current_col, OUTPUT
        str_ = v"String(str_)"
        ch = str_.charAt(0)
        if might_need_semicolon:
            if (not ch or ";}".indexOf(ch) < 0) and not /[;]$/.test(last):
                if options.semicolons or requireSemicolonChars(ch):
                    OUTPUT += ";"
                    current_col += 1
                    current_pos += 1
                else:
                    OUTPUT += "\n"
                    current_pos += 1
                    current_line += 1
                    current_col = 0

                if not options.beautify:
                    might_need_space = False


            might_need_semicolon = False
            maybe_newline()

        if not options.beautify and options.preserve_line and stack[stack.length - 1]:
            target_line = stack[stack.length - 1].start.line
            while current_line < target_line:
                OUTPUT += "\n"
                current_pos += 1
                current_line += 1
                current_col = 0
                might_need_space = False


        if might_need_space:
            prev = last_char()
            if is_identifier_char(prev) and (is_identifier_char(ch) or ch == "\\")
            or /^[\+\-\/]$/.test(ch) and ch == prev:
                OUTPUT += " "
                current_col += 1
                current_pos += 1

            might_need_space = False

        a = str_.split(/\r?\n/)
        n = a.length - 1
        current_line += n
        if n == 0:
            current_col += a[n].length
        else:
            current_col = a[n].length

        current_pos += str_.length
        last = str_
        OUTPUT += str_

    space = options.beautify ? def(): print_(" ")
    : def():
        nonlocal might_need_space
        might_need_space = True

    indent = options.beautify ? def(half):
        if options.beautify:
            print_(make_indent((half ? 0.5 : 0)))
    : noop

    with_indent = options.beautify ? def(col, cont):
        nonlocal indentation
        if col is True:
            col = next_indent()

        save_indentation = indentation
        indentation = col
        ret = cont()
        indentation = save_indentation
        return ret
    : def(col, cont):
        return cont()

    newline = options.beautify ? def():
        print_("\n")
    : noop

    semicolon = options.beautify ? def():
        print_(";")
    : def():
        nonlocal might_need_semicolon
        might_need_semicolon = True

    def force_semicolon():
        nonlocal might_need_semicolon
        might_need_semicolon = False
        print_(";")

    def next_indent():
        return indentation + options.indent_level

    def spaced():
        for v'var i=0; i < arguments.length; i++':
            if i > 0:
                space()
            if type(arguments[i].print) == 'function':
                arguments[i].print(this)
            else:
                print_(arguments[i])  # noqa:undef

    def end_statement():
        semicolon()
        newline()

    def with_block(cont):
        ret = None
        print_("{")
        newline()
        with_indent(next_indent(), def():
            nonlocal ret
            ret = cont()
        )
        indent()
        print_("}")
        return ret

    def with_parens(cont):
        print_("(")
        #XXX: still nice to have that for argument lists
        #var ret = with_indent(current_col, cont)
        ret = cont()
        print_(")")
        return ret

    def with_square(cont):
        print_("[")
        #var ret = with_indent(current_col, cont)
        ret = cont()
        print_("]")
        return ret

    def comma():
        print_(",")
        space()

    def colon():
        print_(":")
        if options.space_colon:
            space()


    add_mapping = (options.source_map ? def(token, name):
        try:
            if token:
                options.source_map.add(token.file or "?", current_line, current_col, token.line, token.col, (not name and token.type == "name" ? token.value : name))
        except:
            AST_Node.warn("Couldn't figure out mapping for {file}:{line},{col} â†’ {cline},{ccol} [{name}]", {
                'file': token.file,
                'line': token.line,
                'col': token.col,
                'cline': current_line,
                'ccol': current_col,
                'name': name or ""
            })
    : noop)

    # retrieve baselib function based on requested key
    def dump_baselib(key):
        indent()
        is_func = key.substr(key.length - 2) == '()'
        v = 'const' if options.js_version > 5 else 'var'
        if is_func:
            ckey = key.substr(0, key.length - 2)
            spaced(v, ckey, '=', '(')
        print_(options.baselib[key])
        if is_func:
            print_(')()')
            semicolon()
        newline()

    def dump_yield():
        indent()
        spaced('var', '_$rapyd$_regenerator', '=', '{}')
        end_statement()
        code = regenerate(False, options.beautify)
        if options.beautify:
            code = code.replace(/\/\/.*$/mg, '\n').replace(/^\s*$/gm, '')  # strip comments
            ci = make_indent(0)
            code = [ci + x for x in code.split('\n')].join('\n')
        print_(code + '(_$rapyd$_regenerator)')
        end_statement()

    # any code that should appear before the main body
    def prologue(module_):
        if options.omit_baselib:
            return
        indent()
        v = 'const' if options.js_version > 5 else 'var'
        print_(v), space()
        spaced.apply(None, (('_$rapyd$_iterator_symbol = (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") ? Symbol.iterator : "iterator-Symbol-5d0927e5554349048cf0e3762a228256"'.split(' '))))
        end_statement()
        indent(), print_(v), space()
        spaced.apply(None, (('_$rapyd$_kwargs_symbol = (typeof Symbol === "function") ? Symbol("kwargs-object") : "kwargs-object-Symbol-5d0927e5554349048cf0e3762a228256"'.split(' '))))
        end_statement()
        indent(), spaced('var', '_$rapyd$_cond_temp'), end_statement()
        baselib_items = {k:True for k in module_.baselib}
        baselib_items['errors'] = True
        baselib_items['containers'] = True
        baselib_items['builtins'] = True
        baselib_items['str'] = True
        deps = options.baselib['#dependencies#']
        # resolve dependencies
        for lib in baselib_items:
            if deps.hasOwnProperty(lib):
                Object.keys(deps[lib]).forEach(def(k): baselib_items[k] = True;)
        # output used items
        for lib in baselib_items:
            if options.js_version >= 6 and (lib == 'iterable' or lib == 'yield'):
                continue
            if lib == 'yield':
                dump_yield()
            else:
                dump_baselib(lib)

    def get():
        return OUTPUT

    # generates: '[name] = '
    def assign_var(name):
        if typeof name is "string":
            print_(name)
        else:
            name.print(this)
        space()
        print_("=")
        space()

    stack = []
    return {
        'index_counter': 0,
        'options':options,
        'get': get,
        'toString': get,
        'indent': indent,
        'indentation': def():
            return indentation
        ,
        'make_indent': make_indent,
        'current_width': def():
            return current_col - indentation
        ,
        'should_break': def():
            return options.width and this.current_width() >= options.width
        ,
        'newline': newline,
        'print': print_,
        'space': space,
        'comma': comma,
        'colon': colon,
        'last': def():
            return last
        ,
        'semicolon': semicolon,
        'force_semicolon': force_semicolon,
        'to_ascii': to_ascii,
        'print_name': def(name):
            print_(make_name(name))
        ,
        'print_string': def(str_):
            print_(encode_string(str_))
        ,
        'next_indent': next_indent,
        'with_indent': with_indent,
        'with_block': with_block,
        'with_parens': with_parens,
        'spaced': spaced,
        'end_statement': end_statement,
        'with_square': with_square,
        'add_mapping': add_mapping,
        'assign': assign_var,
        'prologue': prologue,
        "import": def(module_):
            if not IMPORTED.hasOwnProperty(module_.key):
                IMPORTED[module_.key] = module_
        ,
        'is_main': def():
            return OUTPUT.length == 0
        ,
        'option': def(opt):
            return options[opt]
        ,
        'line': def():
            return current_line
        ,
        'col': def():
            return current_col
        ,
        'pos': def():
            return current_pos
        ,
        'push_node': def(node):
            stack.push(node)
        ,
        'pop_node': def():
            return stack.pop()
        ,
        'stack': def():
            return stack
        ,
        'parent': def(n):
            return stack[stack.length - 2 - (n or 0)]

    }

# -----[ code generators ]-----
def codegen():
    # -----[ utils ]-----
    def DEFPRINT(nodetype, generator):
        nodetype.DEFMETHOD("_codegen", generator)

    AST_Node.DEFMETHOD("print", def(stream, force_parens):
        self = this
        generator = self._codegen
        stream.push_node(self)
        if force_parens or self.needs_parens(stream):
            stream.with_parens(def():
                self.add_comments(stream)
                self.add_source_map(stream)
                generator(self, stream)
            )
        else:
            self.add_comments(stream)
            self.add_source_map(stream)
            generator(self, stream)

        stream.pop_node()
    )
    AST_Node.DEFMETHOD("print_to_string", def(options):
        s = OutputStream(options)
        this.print(s)
        return s.get()
    )
    # -----[ comments ]-----
    AST_Node.DEFMETHOD("add_comments", def(output):
        c = output.option("comments")
        self = this
        if c:
            start = self.start
            if start and not start._comments_dumped:
                start._comments_dumped = True
                comments = start.comments_before
                # XXX: ugly fix for https://github.com/mishoo/RapydScript2/issues/112
                #      if this node is `return` or `throw`, we cannot allow comments before
                #      the returned or thrown value.
                if isinstance(self, AST_Exit) and self.value and self.value.start.comments_before.length > 0:
                    comments = (comments or []).concat(self.value.start.comments_before)
                    self.value.start.comments_before = []

                if c.test:
                    comments = comments.filter(def(comment):
                        return c.test(comment.value)
                    )
                elif typeof c == "function":
                    comments = comments.filter(def(comment):
                        return c(self, comment)
                    )

                comments.forEach(def(c):
                    if c.type == "comment1":
                        output.print("//" + c.value + "\n")
                        output.indent()
                    elif c.type == "comment2":
                        output.print("/*" + c.value + "*/")
                        if start.nlb:
                            output.print("\n")
                            output.indent()
                        else:
                            output.space()


                )


    )
    # -----[ PARENTHESES ]-----
    def PARENS(nodetype, func):
        nodetype.DEFMETHOD("needs_parens", func)

    PARENS(AST_Node, def():
        return False
    )
    # a function expression needs parens around it when it's provably
    # the first token to appear in a statement.
    PARENS(AST_Function, def(output):
        return first_in_statement(output)
    )
    # same goes for an object literal, because otherwise it would be
    # interpreted as a block of code.
    PARENS(AST_Object, def(output):
        return first_in_statement(output)
    )
    PARENS(AST_Unary, def(output):
        p = output.parent()
        return isinstance(p, AST_PropAccess) and p.expression is this
    )
    PARENS(AST_Seq, def(output):
        p = output.parent()
        return isinstance(p, AST_Unary) or isinstance(p, AST_VarDef) or isinstance(p, AST_Dot) or isinstance(p, AST_ObjectProperty) or isinstance(p, AST_Conditional)
    )
    PARENS(AST_Binary, def(output):
        p = output.parent()
        # (foo && bar)()
        if isinstance(p, AST_BaseCall) and p.expression is this:
            return True

        # typeof (foo && bar)
        if isinstance(p, AST_Unary):
            return True

        # (foo && bar)["prop"], (foo && bar).prop
        if isinstance(p, AST_PropAccess) and p.expression is this:
            return True

        # this deals with precedence: 3 * (2 + 1)
        if isinstance(p, AST_Binary):
            po = p.operator
            pp = PRECEDENCE[po]
            so = this.operator
            sp = PRECEDENCE[so]
            if pp > sp or pp == sp and this is p.right and not (so == po and (so == "*" or so == "&&" or so == "||")):
                return True
    )
    PARENS(AST_PropAccess, def(output):
        p = output.parent()
        if isinstance(p, AST_New) and p.expression is this:
            # i.e. new (foo.bar().baz)
            #
            # if there's one call into this subtree, then we need
            # parens around it too, otherwise the call will be
            # interpreted as passing the arguments to the upper New
            # expression.
            try:
                this.walk(new TreeWalker(def(node):
                    if isinstance(node, AST_BaseCall):
                        raise p
                ))
            except as ex:
                if ex is not p:
                    raise ex
                return True
    )
    PARENS(AST_BaseCall, def(output):
        p = output.parent()
        return isinstance(p, AST_New) and p.expression is this
    )
    PARENS(AST_New, def(output):
        p = output.parent()
        if no_constructor_parens(this, output) and (isinstance(p, AST_PropAccess) or isinstance(p, AST_BaseCall) and p.expression is this):
            # (new foo)(bar)
            return True
    )
    PARENS(AST_Number, def(output):
        p = output.parent()
        if this.getValue() < 0 and isinstance(p, AST_PropAccess) and p.expression is this:
            return True
    )
    PARENS(AST_NaN, def(output):
        p = output.parent()
        if isinstance(p, AST_PropAccess) and p.expression is this:
            return True
    )
    def assign_and_conditional_paren_rules(output):
        p = output.parent()
        # !(a = false) â†’ true
        if isinstance(p, AST_Unary):
            return True

        # 1 + (a = 2) + 3 â†’ 6, side effect setting a = 2
        if isinstance(p, AST_Binary) and not (isinstance(p, AST_Assign)):
            return True

        # (a = func)() â€”orâ€” new (a = Object)()
        if isinstance(p, AST_BaseCall) and p.expression is this:
            return True

        # (a = foo) ? bar : baz
        if isinstance(p, AST_Conditional) and p.condition is this:
            return True

        # (a = foo)["prop"] â€”orâ€” (a = foo).prop
        if isinstance(p, AST_PropAccess) and p.expression is this:
            return True

    PARENS(AST_Assign, assign_and_conditional_paren_rules)
    PARENS(AST_Conditional, assign_and_conditional_paren_rules)
    # -----[ PRINTERS ]-----
    DEFPRINT(AST_Directive, def(self, output):
        output.print_string(self.value)
        output.semicolon()
    )
    DEFPRINT(AST_Debugger, def(self, output):
        output.print("debugger")
        output.semicolon()
    )
    # -----[ statements ]-----
    def display_body(body, is_toplevel, output):
        last = body.length - 1
        body.forEach(def(stmt, i):
            if not (isinstance(stmt, AST_EmptyStatement)) and not (isinstance(stmt, AST_Definitions)):
                output.indent()
                stmt.print(output)
                if not (i == last and is_toplevel):
                    output.newline()
        )

    def bind_methods(methods, output):
        # bind the methods
        if methods:
            for arg in methods:
                output.indent()
                output.print("this.")
                output.assign(arg)
                output.print("_$rapyd$_bind")
                output.with_parens(def():
                    output.print("this.")
                    output.print(arg)
                    output.comma()
                    output.print("this")
                )
                output.semicolon()
                output.newline()

    def write_imports(module, output):
        imports = []
        for import_id in Object.keys(module.imports):
            imports.push(module.imports[import_id])
        imports.sort(def(a, b):
            a, b = a.import_order, b.import_order
            return ((a < b) ? -1 : ((a > b) ? 1 : 0))
        )
        if imports.length > 1:
            output.indent()
            output.print('var _$rapyd$_modules = {};')
            output.newline()

        # Declare all variable names exported from the modules as global symbols
        nonlocalvars = {}
        for module_ in imports:
            for name in module_.nonlocalvars:
                nonlocalvars[name] = True
        nonlocalvars = Object.getOwnPropertyNames(nonlocalvars).join(', ')
        if nonlocalvars.length:
            output.indent()
            output.print('var ' + nonlocalvars)
            output.semicolon()
            output.newline()

        # Create the module objects
        for module_ in imports:
            if module_.module_id != '__main__':
                output.indent()
                output.print('_$rapyd$_modules["')
                output.print(module_.module_id)
                output.print('"] = {}')
                output.semicolon()
                output.newline()

        # Output module code
        for module_ in imports:
            if module_.module_id != '__main__':
                print_module(module_, output)

    def write_main_name(output):
        if output.option('write_name'):
            output.newline()
            output.indent()
            output.print('var __name__ = "__main__"')
            output.semicolon()
            output.newline()
            output.newline()

    def display_complex_body(node, is_toplevel, output):
        offset = 0
        # argument offset
        # this is a method, add 'var self = this'
        if isinstance(node, AST_Method) and not node.static:
            output.indent()
            output.print("var")
            output.space()
            output.assign(node.argnames[0])
            output.print("this")
            output.semicolon()
            output.newline()
            offset += 1

        if isinstance(node, AST_Scope):
            # if function takes any arguments
            if node.argnames:
                # If this function has optional parameters/*args/**kwargs declare it differently
                if node.argnames.is_simple_func != True:
                    a = node.argnames
                    kw = 'arguments[arguments.length-1]'
                    # Define all formal parameters
                    for c, arg in enumerate(a):
                        i = c - offset
                        if i >= 0:
                            output.indent()
                            output.print("var")
                            output.space()
                            output.assign(arg)
                            if Object.prototype.hasOwnProperty.call(a.defaults, arg.name):
                                output.spaced('(arguments[' + i + ']', '===', 'undefined', '||',
                                              '(', i, '===', 'arguments.length-1', '&&', 'typeof', kw, '===', '"object"', '&&',
                                              kw, '[_$rapyd$_kwargs_symbol]', '===', 'true))', '?', '')
                                output.with_parens(def():
                                    a.defaults[arg.name].print(output)
                                )
                                output.space()
                                output.print(':')
                                output.space()
                            else:
                                output.spaced('(', i, '===', 'arguments.length-1', '&&', 'typeof', kw, '===', '"object"', '&&',
                                              kw, '[_$rapyd$_kwargs_symbol]', '===', 'true)', '?', 'undefined', ':', '')
                            output.print('arguments[' + i + ']')
                            output.end_statement()
                    if a.kwargs or a.has_defaults:
                        # Look for an options object
                        kw = (a.kwargs) ? a.kwargs.name : '_$rapyd$_kwargs_obj'
                        output.indent()
                        output.spaced('var', kw, '=', 'arguments[arguments.length-1]')
                        output.end_statement()
                        # Ensure kwargs is the options object
                        output.indent()
                        output.spaced('if', '(typeof', kw, '!==', '"object"', '||', kw, '[_$rapyd$_kwargs_symbol]', '!==', 'true)', kw, '=', '{}')
                        output.end_statement()
                        # Read values from the kwargs object for any formal parameters
                        if a.has_defaults:
                            for dname in Object.keys(a.defaults):
                                output.indent()
                                output.spaced('if', '(Object.prototype.hasOwnProperty.call(' + kw + ',', '"' + dname + '"))')
                                output.with_block(def():
                                    output.indent()
                                    output.spaced(dname, '=', kw + '.' + dname)
                                    output.end_statement()
                                    if a.kwargs:
                                        output.indent()
                                        output.spaced('delete', kw + '.' + dname)
                                        output.end_statement()
                                )
                                output.newline()

                    if a.starargs != undefined:
                        # Define the *args parameter, putting in whatever is left after assigning the formal parameters and the options object
                        nargs = a.length - offset
                        output.indent()
                        output.spaced('var', a.starargs.name, '=', 'Array.prototype.slice.call(arguments,', nargs, ')')
                        output.end_statement()
                        # Remove the options object, if present
                        output.indent()
                        output.spaced('if', '(typeof', kw, '===', '"object"', '&&', kw, '[_$rapyd$_kwargs_symbol]', '===', 'true)', a.starargs.name, '.pop()')
                        output.end_statement()

            # rebind parent's methods and bind own methods
            # for now we'll make a naive assumption that a function
            # named __init__ will only occur inside a class
            if output.option("auto_bind") and node.name and node.name.name == "__init__":
                output.indent()
                output.print("_$rapyd$_rebind_all")
                output.with_parens(def():
                    output.print("this")
                    output.comma()
                    output.print("true")
                )
                output.semicolon()
                output.newline()
                bind_methods(node.bound, output)

            declare_vars(node.localvars, output)

        elif isinstance(node, AST_Except):
            if node.argname:
                output.indent()
                output.print("var")
                output.space()
                output.assign(node.argname)
                output.print("_$rapyd$_Exception")
                output.semicolon()
                output.newline()

        display_body(node.body, is_toplevel, output)

    def declare_vars(vars, output):
        # declare all variables as local, unless explictly set otherwise
        if vars.length:
            output.indent()
            output.print("var")
            output.space()
            vars.forEach(def(arg, i):
                if i:
                    output.comma()

                arg.print(output)
            )
            output.semicolon()
            output.newline()

    def declare_exports(module_id, exports, submodules, output):
        seen = {}
        for symbol in exports:
            if not seen.hasOwnProperty(module_id):
                output.newline()
                output.indent()
                output.print('_$rapyd$_modules["' + module_id + '"]["' + symbol.name + '"] = ' + symbol.name)
                seen[symbol.name] = True
                output.semicolon()
                output.newline()

    def declare_submodules(module_id, submodules, output):
        seen = {}
        for sub_module_id in submodules:
            if not seen.hasOwnProperty(sub_module_id):
                seen[sub_module_id] = True
                key = sub_module_id.split('.')[-1]
                output.indent()
                output.spaced('_$rapyd$_modules["' + module_id + '"]["' + key + '"]', '=', '_$rapyd$_modules["' + sub_module_id + '"]')
                output.end_statement()

    def unpack_tuple(elems, output, in_statement):
        elems.forEach(def(elem, i):
            output.indent()
            output.assign(elem)
            output.print("_$rapyd$_Unpack")
            output.with_square(def():
                output.print(i)
            )
            if not in_statement or i < elems.length - 1:
                output.semicolon()
                output.newline()
        )

    AST_StatementWithBody.DEFMETHOD("_do_print_body", def(output):
        force_statement(this.body, output)
    )
    DEFPRINT(AST_Statement, def(self, output):
        self.body.print(output)
        output.semicolon()
    )
    DEFPRINT(AST_Toplevel, def(self, output):
        is_main = output.is_main()
        if is_main and self.shebang:
            output.print(self.shebang)
            output.newline()

        if output.option("private_scope") and is_main:
            output.with_parens(def():
                output.print("function()")
                output.with_block(def():
                    # strict mode is more verbose about errors, and less forgiving about them
                    # kind of like Python
                    output.indent()
                    output.print('"use strict;"')
                    output.end_statement()

                    output.prologue(self)
                    write_imports(self, output)
                    output.newline()
                    output.indent()
                    output.with_parens(def():
                        output.print("function()")
                        output.with_block(def():
                            write_main_name(output)
                            output.newline()
                            display_complex_body(self, True, output)
                            output.newline()
                        )
                    )
                    output.print("();")
                    output.newline()
                )
            )
            output.print("();")
            output.print("")
        else:
            if is_main:
                output.prologue(self)
                write_imports(self, output)
                write_main_name(output)

            display_body(self.body, True, output)

    )
    def print_module(self, output):

        def output_module(output):
            declare_vars(self.localvars, output)
            display_body(self.body, True, output)
            declare_exports(self.module_id, self.exports, self.submodules, output)

        output.newline()
        output.indent()
        output.with_parens(def():
            output.print("function()")
            output.with_block(def():
                # dump the logic of this module
                if output.option('write_name'):
                    output.indent()
                    output.print('var ')
                    output.assign('__name__')
                    output.print('"' + self.module_id + '"')
                    output.semicolon()
                    output.newline()
                def output_key(beautify, auto_bind, js_version):
                    return 'beautify:' + beautify + ' auto_bind:' + auto_bind + ' js_version:' + js_version
                okey = output_key(output.option('beautify'), output.option('auto_bind'), output.option('js_version'))
                if self.is_cached and okey in self.outputs:
                    output.print(self.outputs[okey])
                    declare_submodules(self.module_id, self.submodules, output)
                else:
                    output_module(output)
                    declare_submodules(self.module_id, self.submodules, output)
                    if self.srchash and self.filename:
                        cached = {
                            'version':COMPILER_VERSION, 'signature':self.srchash, 'classes': {}, 'baselib':self.baselib,
                            'nonlocalvars':self.nonlocalvars, 'imported_module_ids':self.imported_module_ids, 'exports':[],
                            'outputs':{},
                        }
                        for cname in Object.keys(self.classes):
                            cobj = self.classes[cname]
                            cached.classes[cname] = {'name':{'name':cobj.name.name}, 'static':cobj.static, 'bound':cobj.bound}
                        for symdef in self.exports:
                            cached.exports.push({'name':symdef.name})
                        for beautify in [True, False]:
                            for auto_bind in [True, False]:
                                for js_version in [5, 6]:
                                    co = OutputStream({'beautify':beautify, 'auto_bind':auto_bind, 'js_version':js_version, 'private_scope':False, 'write_name':False})
                                    co.with_indent(output.indentation(), def():
                                        output_module(co)
                                    )
                                    raw = co.toString()
                                    cached.outputs[output_key(beautify, auto_bind, js_version)] = raw
                        try:
                            writefile(self.filename + '-cached', JSON.stringify(cached, None, '\t'))
                        except Error as e:
                            console.error('Failed to write output cache file:', self.filename + '-cached', 'with error:', e)
            )
        )
        output.print("()")
        output.semicolon()
        output.newline()

    DEFPRINT(AST_Imports, def(container, output):
        def add_aname(aname, key, from_import):
            output.print('var ')
            output.assign(aname)
            output.print('_$rapyd$_modules["')
            output.print(key)
            output.print('"]')
            if from_import:
                output.print('.')
                output.print(from_import)
            output.semicolon()
            output.newline()
            output.indent()

        for self in container.imports:
            output.import(self.module)
            if self.argnames:
                # A from import
                for argname in self.argnames:
                    akey = (argname.alias) ? argname.alias.name : argname.name
                    add_aname(akey, self.key, argname.name)
            else:
                if self.alias:
                    add_aname(self.alias.name, self.key, False)
                else:
                    bound_name = self.key.split('.', 1)[0]
                    add_aname(bound_name, bound_name, False)

    )
    DEFPRINT(AST_SimpleStatement, def(self, output):
        if not (isinstance(self.body, AST_EmptyStatement)):
            self.body.print(output)
            output.semicolon()
    )
    def print_bracketed(node, output, complex):
        if node.body.length > 0:
            output.with_block(def():
                if complex:
                    display_complex_body(node, False, output)
                else:
                    display_body(node.body, False, output)
            )
        else:
            output.print("{}")

    DEFPRINT(AST_BlockStatement, def(self, output):
        print_bracketed(self, output)
    )

    DEFPRINT(AST_EmptyStatement, def(self, output):
        pass
    )

    DEFPRINT(AST_Do, def(self, output):
        output.print("do")
        output.space()
        self._do_print_body(output)
        output.space()
        output.print("while")
        output.space()
        output.with_parens(def(): self.condition.print(output);)
        output.semicolon()
    )

    DEFPRINT(AST_While, def(self, output):
        output.print("while")
        output.space()
        output.with_parens(def(): self.condition.print(output);)
        output.space()
        self._do_print_body(output)
    )

    def is_simple_for_in(self):
        # return true if this loop can be simplified into a basic for (i in j) loop
        if isinstance(self.object, AST_BaseCall)
        and isinstance(self.object.expression, AST_SymbolRef)
        and self.object.expression.name == "dir" and self.object.args.length == 1:
            return True
        return False

    def is_simple_for(self):
        # returns true if this loop can be simplified into a basic for(i=n;i<h;i++) loop
        if isinstance(self.object, AST_BaseCall)
        and isinstance(self.object.expression, AST_SymbolRef)
        and self.object.expression.name == "range"
        and not (isinstance(self.init, AST_Array))
        and (
            self.object.args.length < 3 or (
                isinstance(self.object.args.slice(-1)[0], AST_Number)
                or isinstance(self.object.args.slice(-1)[0], AST_Unary)
                    and self.object.args.slice(-1)[0].operator == "-"
                    and isinstance(self.object.args.slice(-1)[0].expression, AST_Number)
            )
        ):
            return True
        return False

    AST_ForIn.DEFMETHOD("_do_print_body", def(output):
        self = this
        output.with_block(def():
            if not (is_simple_for(self) or is_simple_for_in(self)):
                # if we're using multiple iterators, unpack them
                output.indent()
                if output.option('js_version') == 5:
                    itervar = "_$rapyd$_Iter" + output.index_counter + "[_$rapyd$_Index" + output.index_counter + "]"
                else:
                    itervar = "_$rapyd$_Index" + output.index_counter
                if isinstance(self.init, AST_Array):
                    flat = self.init.flatten()
                    output.assign("_$rapyd$_Unpack")
                    if flat.length > self.init.elements.length:
                        output.print('_$rapyd$_flatten(' + itervar + ')')
                    else:
                        output.print(itervar)
                    output.end_statement()
                    unpack_tuple(flat, output)
                else:
                    output.assign(self.init)
                    output.print(itervar)
                    output.end_statement()

                output.index_counter += 1

            self.body.body.forEach(def(stmt, i):
                output.indent()
                stmt.print(output)
                output.newline()
            )
        )
    )

    def init_es6_itervar(output, itervar):
        output.indent()
        output.spaced(itervar, '=', '((typeof', itervar + '[Symbol.iterator]', '===', '"function")', '?',
                        '('+itervar, 'instanceof', 'Map', '?', itervar + '.keys()', ':', itervar+')', ':', 'Object.keys(' + itervar + '))')
        output.end_statement()

    DEFPRINT(AST_ForIn, def(self, output):
        if is_simple_for(self):
            # optimize range() into a simple for loop
            increment = None
            args = self.object.args
            tmp_ = args.length
            if tmp_ == 1:
                start = 0
                end = args[0]
            elif tmp_ == 2:
                start = args[0]
                end = args[1]
            elif tmp_ == 3:
                start = args[0]
                end = args[1]
                increment = args[2]

            output.print("for")
            output.space()
            output.with_parens(def():
                output.assign(self.init)
                start.print ? start.print(output) : output.print(start)
                output.semicolon()
                output.space()
                self.init.print(output)
                output.space()
                isinstance(increment, AST_Unary) ? output.print(">") : output.print("<")
                output.space()
                end.print(output)
                output.semicolon()
                output.space()
                self.init.print(output)
                if increment and (not (isinstance(increment, AST_Unary)) or increment.expression.value != "1"):
                    if isinstance(increment, AST_Unary):
                        output.print("-=")
                        increment.expression.print(output)
                    else:
                        output.print("+=")
                        increment.print(output)
                else:
                    if isinstance(increment, AST_Unary):
                        output.print("--")
                    else:
                        output.print("++")
            )
        elif is_simple_for_in(self):
            # optimize dir() into a simple for in loop
            output.print("for")
            output.space()
            output.with_parens(def():
                self.init.print(output)
                output.space()
                output.print('in')
                output.space()
                self.object.args[0].print(output)
            )
        else:
            # regular loop
            if output.options.js_version == 5:
                output.assign("var _$rapyd$_Iter" + output.index_counter)
                output.print("_$rapyd$_Iterable")
                output.with_parens(def():
                    self.object.print(output)
                )
                output.semicolon()
                output.newline()
                output.indent()
                output.print("for")
                output.space()
                output.with_parens(def():
                    output.print("var")
                    output.space()
                    output.assign("_$rapyd$_Index" + output.index_counter)
                    output.print("0")
                    output.semicolon()
                    output.space()
                    output.print("_$rapyd$_Index" + output.index_counter)
                    output.space()
                    output.print("<")
                    output.space()
                    output.print("_$rapyd$_Iter" + output.index_counter + ".length")
                    output.semicolon()
                    output.space()
                    output.print("_$rapyd$_Index" + output.index_counter + "++")
                )
            else:
                itervar = "_$rapyd$_Iter" + output.index_counter
                output.assign("var " + itervar)
                self.object.print(output)
                output.end_statement()
                init_es6_itervar(output, itervar)
                output.indent()
                output.spaced('for', '(var', '_$rapyd$_Index' + output.index_counter, 'of', itervar + ')')

        output.space()
        self._do_print_body(output)
    )

    AST_ForJS.DEFMETHOD("_do_print_body", def(output):
        self = this
        output.with_block(def():
            self.body.body.forEach(def(stmt, i):
                output.indent()
                stmt.print(output)
                output.newline()
            )
        )
    )

    DEFPRINT(AST_ForJS, def(self, output):
        output.print("for")
        output.space()
        output.with_parens(def():
            self.condition.print(output)
        )
        output.space()
        self._do_print_body(output)
    )

    DEFPRINT(AST_ListComprehension, def(self, output):
        result_obj = {'ListComprehension':'[]', 'DictComprehension':'{}', 'SetComprehension':'_$rapyd$_set()'}[self.TYPE]
        if self.TYPE == 'DictComprehension':
            if self.is_pydict:
                result_obj = '_$rapyd$_dict()'
                add_to_result = def():
                    output.indent()
                    output.print('_$rapyd$_Result.set')
                    output.with_parens(def():
                        self.statement.print(output)
                        output.space(), output.print(','), output.space()
                        output.with_parens(def():
                            if self.value_statement.TYPE == 'Seq':
                                output.with_square(def():self.value_statement.print(output);)
                            else:
                                self.value_statement.print(output)
                        )
                    )
                    output.end_statement()
            else:
                add_to_result = def():
                    output.indent()
                    output.print('_$rapyd$_Result')
                    output.with_square(def():
                        self.statement.print(output)
                    )
                    output.space(), output.print('='), output.space()
                    output.with_parens(def():
                        if self.value_statement.TYPE == 'Seq':
                            output.with_square(def():self.value_statement.print(output);)
                        else:
                            self.value_statement.print(output)
                    )
                    output.end_statement()
        else:
            push_func = "_$rapyd$_Result." + ((self.TYPE == 'ListComprehension') ? 'push' : 'add')
            add_to_result = def():
                output.indent()
                output.print(push_func)
                output.with_parens(def():
                    if self.statement.TYPE == 'Seq':
                        output.with_square(def():self.statement.print(output);)
                    else:
                        self.statement.print(output)
                )
                output.end_statement()

        output.with_parens(def():
            output.print("function")
            output.print("()")
            output.space()
            output.with_block(def():
                output.indent()
                output.assign("var _$rapyd$_Iter")
                if output.option('js_version') == 5:
                    output.print("_$rapyd$_Iterable")
                    output.with_parens(def():
                        self.object.print(output)
                    )
                else:
                    self.object.print(output)

                output.comma()
                output.assign("_$rapyd$_Result")
                output.print(result_obj)
                # make sure to locally scope loop variables
                if isinstance(self.init, AST_Array):
                    self.init.elements.forEach(def(i):
                        output.comma()
                        i.print(output)
                    )
                else:
                    output.comma()
                    self.init.print(output)
                output.end_statement()

                if output.option('js_version') != 5:
                    init_es6_itervar(output, '_$rapyd$_Iter')
                output.indent()
                output.print("for")
                output.space()
                output.with_parens(def():
                    if output.option('js_version') == 5:
                        output.print("var")
                        output.space()
                        output.assign("_$rapyd$_Index")
                        output.print("0")
                        output.semicolon()
                        output.space()
                        output.print("_$rapyd$_Index")
                        output.space()
                        output.print("<")
                        output.space()
                        output.print("_$rapyd$_Iter.length")
                        output.semicolon()
                        output.space()
                        output.print("_$rapyd$_Index++")
                    else:
                        output.spaced('var', '_$rapyd$_Index', 'of', '_$rapyd$_Iter')
                )
                output.space()
                output.with_block(def():
                    output.indent()
                    itervar = (output.option('js_version') == 5) ? '_$rapyd$_Iter[_$rapyd$_Index]' : '_$rapyd$_Index'
                    if isinstance(self.init, AST_Array):
                        flat = self.init.flatten()
                        output.assign("_$rapyd$_Unpack")
                        if flat.length > self.init.elements.length:
                            output.print('_$rapyd$_flatten(' + itervar + ')')
                        else:
                            output.print(itervar)
                        output.end_statement()
                        unpack_tuple(flat, output)
                    else:
                        output.assign(self.init)
                        output.print(itervar)
                        output.end_statement()

                    if self.condition:
                        output.indent()
                        output.print("if")
                        output.space()
                        output.with_parens(def(): self.condition.print(output);)
                        output.space()
                        output.with_block(def():
                            add_to_result()
                        )
                        output.newline()
                    else:
                        add_to_result()
                )
                output.newline()
                if self.TYPE == 'ListComprehension':
                    output.indent()
                    output.spaced('_$rapyd$_Result', '=', '_$rapyd$_list_constructor(_$rapyd$_Result)')
                    output.end_statement()
                output.indent()
                output.print("return _$rapyd$_Result")
                output.end_statement()
            )
        )
        output.print("()")
    )
    DEFPRINT(AST_With, def(self, output):
        output.print("with")
        output.space()
        output.with_parens(def():
            self.expression.print(output)
        )
        output.space()
        self._do_print_body(output)
    )

    # -----[ functions ]-----
    def decorate(decorators, output, func):
        wrap = def(d):
            if d.length:
                output.print(d[0].name)
                output.with_parens(def():
                    wrap(d.slice(1))
                )
            else:
                func()
        wrap(decorators)

    def function_args(argnames, output, strip_first):
        output.with_parens(def():
            if argnames and argnames.length and (argnames.is_simple_func == True or argnames.is_simple_func == undefined):
                ((strip_first) ? argnames.slice(1) : argnames).forEach(def(arg, i):
                    if i:
                        output.comma()
                    arg.print(output)
                )
        )
        output.space()

    def function_definition(self, output, nokeyword, strip_first):
        if not nokeyword:
            output.print("function")

        if self.name:
            output.space()
            self.name.print(output)
        if self.is_generator:
            output.print('()'), output.space()
            output.with_block(def():
                if output.options.js_version >= 6:
                    output.print('function* js_generator')
                    function_args(self.argnames, output, strip_first)
                    print_bracketed(self, output, True)
                else:
                    temp = OutputStream({'beautify':True})
                    temp.print('function* js_generator')
                    function_args(self.argnames, temp, strip_first)
                    print_bracketed(self, temp, True)
                    transpiled = regenerate(temp.get(), output.options.beautify).replace(/regeneratorRuntime.(wrap|mark)/g, '_$rapyd$_regenerator.regeneratorRuntime.$1')
                    if output.options.beautify:
                        ci = output.make_indent(0)
                        transpiled = [ci + x for x in transpiled.split('\n')].join('\n')
                    output.print(transpiled)
                output.newline()
                output.indent()
                output.spaced('var', 'result', '=', 'js_generator.apply(this,', 'arguments)')
                output.end_statement()
                # Python's generator objects use a separate method to send data to the generator
                output.indent()
                output.spaced('result.send', '=', 'result.next')
                output.end_statement()
                output.indent()
                output.spaced('return', 'result')
                output.end_statement()
            )
        else:
            function_args(self.argnames, output, strip_first)
            print_bracketed(self, output, True)

    AST_Lambda.DEFMETHOD("_do_print", def(output, nokeyword):
        self = this
        if self.decorators and self.decorators.length:
            output.print("var")
            output.space()
            output.assign(self.name.name)
            decorate(self.decorators, output, def():function_definition(self, output, nokeyword, False);)
            output.semicolon()
        else:
            function_definition(self, output, nokeyword, False)
    )
    DEFPRINT(AST_Lambda, def(self, output):
        self._do_print(output)
    )
    # -----[ classes ]-----
    AST_Class.DEFMETHOD("_do_print", def(output):
        self = this
        if self.external:
            return

        class_def = def(method, is_var):
            output.indent()
            self.name.print(output)
            if not is_var and method and self.static.indexOf(method) != -1:
                output.assign("." + method)
            else:
                if is_var:
                    output.assign(".prototype[" + method + "]")
                else:
                    output.assign(".prototype" + ((method ? "." + method : "")))

        define_method = def(stmt):
            name = stmt.name.name
            class_def(name)
            # only strip first argument if the method is static
            strip_first = self.static.indexOf(name) == -1

            # decorate the method
            if stmt.decorators and stmt.decorators.length:
                decorate(stmt.decorators, output, def():function_definition(stmt, output, False, strip_first);)
            else:
                function_definition(stmt, output, False, strip_first)
            output.semicolon()
            output.newline()

        # generate constructor
        def internalsub():
            if self.init or self.parent:
                output.print("function")
                output.space()
                self.name.print(output)
                output.print("()")
                output.space()
                output.with_block(def():
                    bind_methods(self.bound, output)
                    output.indent()
                    cname = (self.name) ? self.name : self.parent
                    cname.print(output)
                    output.print(".prototype.__init__.apply")
                    output.with_parens(def():
                        output.print("this")
                        output.comma()
                        output.print("arguments")
                    )
                    output.semicolon()
                    output.newline()
                )
            else:
                # no init method or parent, create empty init
                output.print("function")
                output.space()
                self.name.print(output)
                output.print("()")
                output.space()
                output.with_block(def():
                    bind_methods(self.bound, output)
                )

        # decorate the class
        if self.decorators and self.decorators.length:
            output.print('var ')
            output.assign(self.name)
            decorate(self.decorators, output, internalsub)
            output.semicolon()
        else:
            internalsub()

        output.newline()
        # inheritance
        if self.parent:
            output.indent()
            output.print("_$rapyd$_extends")
            output.with_parens(def():
                self.name.print(output)
                output.comma()
                self.parent.print(output)
            )
            output.semicolon()
            output.newline()

        # actual methods
        self.body.forEach(def(stmt, i):
            if isinstance(stmt, AST_Method):
                define_method(stmt)
                if stmt.name.name == '__iter__':
                    class_def('_$rapyd$_iterator_symbol', True)
                    self.name.print(output)
                    output.print('.prototype.' + stmt.name.name)
                    output.end_statement()

            elif isinstance(stmt, AST_Class):
                console.error('Nested classes aren\'t supported yet')  # noqa:undef
        )

        # Other statements in the class context
        self.statements.forEach(def(stmt):
            if not isinstance(stmt, AST_Method):
                output.indent()
                stmt.print(output)
                output.newline()
        )

    )
    DEFPRINT(AST_Class, def(self, output):
        self._do_print(output)
    )

    # -----[ exits ]-----
    AST_Exit.DEFMETHOD("_do_print", def(output, kind):
        self = this
        output.print(kind)
        if self.value:
            output.space()
            self.value.print(output)

        output.semicolon()
    )
    DEFPRINT(AST_Yield, def(self, output):
        self._do_print(output, "yield" + (self.is_yield_from ? '*' : ''))
    )
    DEFPRINT(AST_Return, def(self, output):
        self._do_print(output, "return")
    )
    DEFPRINT(AST_Throw, def(self, output):
        self._do_print(output, "throw")
    )

    # -----[ loop control ]-----
    AST_LoopControl.DEFMETHOD("_do_print", def(output, kind):
        output.print(kind)
        if this.label:
            output.space()
            this.label.print(output)

        output.semicolon()
    )
    DEFPRINT(AST_Break, def(self, output):
        self._do_print(output, "break")
    )
    DEFPRINT(AST_Continue, def(self, output):
        self._do_print(output, "continue")
    )

    # -----[ if ]-----
    def make_then(self, output):
        if output.option("bracketize"):
            make_block(self.body, output)
            return

        # The squeezer replaces "block"-s that contain only a single
        # statement with the statement itself; technically, the AST
        # is correct, but this can create problems when we output an
        # IF having an ELSE clause where the THEN clause ends in an
        # IF *without* an ELSE block (then the outer ELSE would refer
        # to the inner IF).  This function checks for this case and
        # adds the block brackets if needed.
        if not self.body:
            return output.force_semicolon()

        if isinstance(self.body, AST_Do) and output.option("ie_proof"):
            # https://github.com/mishoo/RapydScript/issues/#issue/57 IE
            # croaks with "syntax error" on code like this: if (foo)
            # do ... while(cond); else ...  we need block brackets
            # around do/while
            make_block(self.body, output)
            return

        b = self.body
        while True:
            if isinstance(b, AST_If):
                if not b.alternative:
                    make_block(self.body, output)
                    return

                b = b.alternative
            elif isinstance(b, AST_StatementWithBody):
                b = b.body
            else:
                break

        force_statement(self.body, output)

    DEFPRINT(AST_If, def(self, output):
        output.print("if")
        output.space()
        output.with_parens(def(): self.condition.print(output);)
        output.space()
        if self.alternative:
            make_then(self, output)
            output.space()
            output.print("else")
            output.space()
            force_statement(self.alternative, output)
        else:
            self._do_print_body(output)

    )

    # -----[ exceptions ]-----
    DEFPRINT(AST_Try, def(self, output):
        output.print("try")
        output.space()
        print_bracketed(self, output)
        if self.bcatch:
            output.space()
            self.bcatch.print(output)

        if self.bfinally:
            output.space()
            self.bfinally.print(output)
    )
    DEFPRINT(AST_Catch, def(self, output):
        output.print("catch")
        output.space()
        output.with_parens(def():
            output.print("_$rapyd$_Exception")
        )
        output.space()
        #        print_bracketed(self, output)
        if self.body.length > 1 or self.body[0].errors.length:
            output.with_block(def():
                output.indent()
                no_default = True
                self.body.forEach(def(exception, i):
                    nonlocal no_default
                    if i:
                        output.print("else ")

                    if exception.errors.length:
                        output.print("if")
                        output.space()
                        output.with_parens(def():
                            exception.errors.forEach(def(err, i):
                                if i:
                                    output.newline()
                                    output.indent()
                                    output.print("||")
                                    output.space()

                                output.print("_$rapyd$_Exception")
                                output.space()
                                output.print("instanceof")
                                output.space()
                                err.print(output)
                            )
                        )
                        output.space()
                    else:
                        no_default = False
                    print_bracketed(exception, output, True)
                    output.space()
                )
                if no_default:
                    output.print("else")
                    output.space()
                    output.with_block(def():
                        output.indent()
                        output.print("throw")
                        output.space()
                        output.print("_$rapyd$_Exception")
                        output.semicolon()
                        output.newline()
                    )
                output.newline()
            )
        else:
            print_bracketed(self.body[0], output, True)
    )
    DEFPRINT(AST_Finally, def(self, output):
        output.print("finally")
        output.space()
        print_bracketed(self, output)
    )

    # -----[ var/const ]-----
    AST_Definitions.DEFMETHOD("_do_print", def(output, kind):
        output.print(kind)
        output.space()
        this.definitions.forEach(def(def_, i):
            if i:
                output.comma()
            def_.print(output)
        )
        p = output.parent()
        in_for = isinstance(p, AST_ForIn)
        avoid_semicolon = in_for and p.init is this
        if not avoid_semicolon:
            output.semicolon()
    )
    DEFPRINT(AST_Var, def(self, output):
        self._do_print(output, "var")
    )
    DEFPRINT(AST_Const, def(self, output):
        self._do_print(output, "const")
    )
    def parenthesize_for_noin(node, output, noin):
        if not noin:
            node.print(output)
        else:
            try:
                # need to take some precautions here:
                #    https://github.com/mishoo/RapydScript2/issues/60
                node.walk(new TreeWalker(def(node):
                    if isinstance(node, AST_Binary) and node.operator == "in":
                        raise output
                ))
                node.print(output)
            except as ex:
                if ex is not output:
                    raise ex
                node.print(output, True)

    DEFPRINT(AST_VarDef, def(self, output):
        self.name.print(output)
        if self.value:
            output.assign("")
            #            output.space()
            #            output.print("=")
            #            output.space()
            p = output.parent(1)
            noin = isinstance(p, AST_ForIn)
            parenthesize_for_noin(self.value, output, noin)
    )

    # -----[ other expressions ]-----
    DEFPRINT(AST_BaseCall, def(self, output):

        if isinstance(self, AST_ClassCall):
            # class methods are called through the prototype unless static
            if self.static:
                self.class.print(output)
                output.print(".")
                output.print(self.method)
            else:
                self.class.print(output)
                output.print(".prototype.")
                output.print(self.method)
                output.print(".call")
        else:
            # regular function call
            self.expression.print(output)

        if isinstance(self, AST_New) and no_constructor_parens(self, output):
            return

        has_kwarg_items = self.args.kwarg_items and self.args.kwarg_items.length
        has_kwarg_formals = self.args.kwargs and self.args.kwargs.length
        has_kwargs = has_kwarg_items or has_kwarg_formals

        output_kwargs = def():
            output.print('_$rapyd$_desugar_kwargs(')
            if has_kwarg_items:
                self.args.kwarg_items.forEach(def(kwname, i):
                    if i > 0:
                        output.print(',')
                        output.space()
                    kwname.print(output)
                )
                if has_kwarg_formals:
                    output.print(',')
                    output.space()

            if has_kwarg_formals:
                output.print('{')
                self.args.kwargs.forEach(def(pair, i):
                    if i: output.comma()
                    pair[0].print(output)
                    output.print(':')
                    output.space()
                    pair[1].print(output)
                )
                output.print('}')
            output.print(')')

        if self.args.starargs:
            if isinstance(self, AST_New):
                obj = '_$rapyd$_new_temp'
            else:
                obj = (self.expression.expression ? self.expression.expression.name : "this")
            output.print(".apply")
            output.with_parens(def():
                output.print(obj)
                output.comma()
                # basic arguments
                i = 0
                while i < self.args.length:
                    expr = self.args[i]
                    is_first = i == 0
                    if not is_first:
                        output.print('.concat(')
                    if expr.is_array:
                        expr.print(output)
                        i += 1
                    else:
                        output.print('[')
                        while i < self.args.length and not self.args[i].is_array:
                            self.args[i].print(output)
                            if i + 1 < self.args.length and not self.args[i+1].is_array:
                                output.print(',')
                                output.space()
                            i += 1
                        output.print(']')
                    if not is_first:
                        output.print(')')

                # now kwargs
                if has_kwargs:
                    if self.args.length:
                        output.print('.concat(')
                    output.print('[')
                    output_kwargs()
                    output.print(']')
                    if self.args.length:
                        output.print(')')
            )
        else:
            output.with_parens(def():
                # normal args
                self.args.forEach(def(expr, i):
                    if i:
                        output.comma()
                    expr.print(output)
                )

                # kwargs as hash
                if has_kwargs:
                    if self.args.length:
                        output.print(',')
                        output.space()
                    output_kwargs()
            )
    )
    DEFPRINT(AST_New, def(self, output):
        if self.args.starargs:
            output.with_parens(def():
                output.print('function()')
                output.with_block(def():
                    output.indent()
                    output.print('var _$rapyd$_new_temp = Object.create(')
                    self.expression.print(output)
                    output.print(')')
                    output.end_statement(), output.indent()
                    AST_BaseCall.prototype._codegen(self, output)
                    output.end_statement(), output.indent()
                    output.print('return _$rapyd$_new_temp')
                    output.end_statement()
                )
            )
            output.print('()')
        else:
            output.print("new")
            output.space()
            AST_BaseCall.prototype._codegen(self, output)
    )
    AST_Seq.DEFMETHOD("_do_print", def(output):
        self = this
        p = output.parent()
        print_seq = def():
            self.car.print(output)
            if self.cdr:
                output.comma()
                if output.should_break():
                    output.newline()
                    output.indent()
                self.cdr.print(output)

        # this will effectively convert tuples to arrays
        if isinstance(p, AST_Binary)
        or isinstance(p, AST_Return)
        or isinstance(p, AST_Array)
        or isinstance(p, AST_BaseCall)
        or isinstance(p, AST_SimpleStatement):
            output.with_square(print_seq)
        else:
            print_seq()
    )
    DEFPRINT(AST_Seq, def(self, output):
        self._do_print(output)
    )
    DEFPRINT(AST_Dot, def(self, output):
        expr = self.expression
        expr.print(output)
        if isinstance(expr, AST_Number) and expr.getValue() >= 0:
            if not /[xa-f.]/i.test(output.last()):
                output.print(".")
        output.print(".")
        # the name after dot would be mapped about here.
        output.add_mapping(self.end)
        output.print_name(self.property)
    )
    DEFPRINT(AST_Sub, def(self, output):
        self.expression.print(output)
        output.print("[")
        # parse negative constants into len-constant
        if isinstance(self.property, AST_Unary) and self.property.operator == "-"
        and isinstance(self.property.expression, AST_Number):
            # TODO: this might parse incorrectly if expression is a
            # function call that might not return the same result
            # when called repeatedly. We might eventually want to
            # save the return to a temporary variable and use that
            # instead if expression is a function. Or we could just
            # throw an error if negative indices are used with a
            # type that's not AST_SymbolVar
            self.expression.print(output)
            output.print(".length")

        self.property.print(output)
        output.print("]")
    )
    DEFPRINT(AST_ItemAccess, def(self, output):
        self.expression.print(output)
        output.print('.__' + (self.assignment ? 'setitem' : 'getitem') + '__')
        output.with_parens(def():
            self.property.print(output)
            if self.assignment:
                output.comma()
                self.assignment.print(output)
        )
    )
    DEFPRINT(AST_Splice, def(self, output):
        # splice assignment via pythonic array[start:end]
        output.print('[].splice.apply')
        output.with_parens(def():
            self.expression.print(output)
            output.comma()
            output.with_square(def():
                self.property.print(output)
                output.comma()
                self.property2.print(output)
                output.print('-')
                self.property.print(output)
            )
            output.print('.concat')
            output.with_parens(def():
                self.assignment.print(output)
            )
        )
    )
    DEFPRINT(AST_UnaryPrefix, def(self, output):
        op = self.operator
        output.print(op)
        if /^[a-z]/i.test(op):
            output.space()
        self.expression.print(output)
    )
    DEFPRINT(AST_UnaryPostfix, def(self, output):
        self.expression.print(output)
        output.print(self.operator)
    )
    def write_instanceof(left, right, output):
        def single(left, right):
            if right.name == 'Array' or right.name == 'list':
                output.print('Array.isArray')
                output.with_parens(def():left.print(output);)
            else:
                output.spaced(left, 'instanceof', right)
        if isinstance(right, AST_Seq):
            right = new AST_Array({'elements':right.to_array()})
        if isinstance(right, AST_Array):
            output.with_parens(def():
                right.elements.forEach(def (right, i, arr):
                    single(left, right)
                    if arr.length > 1 and i < arr.length - 1:
                        output.space(), output.print('||'), output.space()
                )
            )
        else:
            single(left, right)

    DEFPRINT(AST_Binary, def(self, output):
        comparators = {
            "<": True,
            ">": True,
            "<=": True,
            ">=": True,
            "==": True,
            "!=": True
        }
        function_ops = {
            "in": "_$rapyd$_in",
            "**": "Math.pow"
        }

        if self.operator in function_ops:
            output.print(function_ops[self.operator])
            output.with_parens(def():
                self.left.print(output)
                output.comma()
                self.right.print(output)
            )
        elif comparators[self.operator] and isinstance(self.left, AST_Binary) and comparators[self.left.operator]:
            if isinstance(self.left.right, AST_Symbol):
                # left side compares against a regular variable,
                # no caching needed
                self.left.print(output)
                leftvar = self.left.right.name
            else:
                # some logic is being performed, let's cache it
                self.left.left.print(output)
                output.space()
                output.print(self.left.operator)
                output.space()
                output.with_parens(def():
                    nonlocal leftvar
                    output.assign("_$rapyd$_cond_temp")
                    self.left.right.print(output)
                    leftvar = "_$rapyd$_cond_temp"
                )

            output.space()
            output.print("&&")
            output.space()
            output.print(leftvar)
            output.space()
            output.print(self.operator)
            output.space()
            self.right.print(output)
        elif self.operator == '//':
            output.print('Math.floor')
            output.with_parens(def():
                self.left.print(output)
                output.space()
                output.print('/')
                output.space()
                self.right.print(output)
            )
        elif self.operator == 'instanceof':
            write_instanceof(self.left, self.right, output)
        else:
            output.spaced(self.left, self.operator, self.right)
    )

    def print_assignment(self, output):
        flattened = False
        left = self.left
        if isinstance(left, AST_Seq):
            left = new AST_Array({'elements':v'[left.car, left.cdr]'})
        if isinstance(left, AST_Array):
            flat = left.flatten()
            flattened = flat.length > left.elements.length
            output.print("_$rapyd$_Unpack")
        else:
            left.print(output)
        output.space()
        output.print(self.operator)
        output.space()
        if flattened:
            output.print('_$rapyd$_flatten')
            output.with_parens(def():self.right.print(output);)
        else:
            self.right.print(output)
        if isinstance(left, AST_Array):
            output.semicolon()
            output.newline()
            unpack_tuple(flat, output, True)

    DEFPRINT(AST_Assign, def(self, output):
        if self.operator == '//=':
            output.assign(self.left)
            output.print('Math.floor')
            output.with_parens(def():
                self.left.print(output)
                output.space()
                output.print('/')
                output.space()
                self.right.print(output)
            )
            return
        print_assignment(self, output)

    )
    def write_conditional(output, condition, consequent, alternative):
        output.with_parens(def():condition.print(output);)
        output.space()
        output.print("?")
        output.space()
        consequent.print(output)
        output.space()
        output.colon()
        alternative.print(output)

    DEFPRINT(AST_Conditional, def(self, output):
        write_conditional(output, self.condition, self.consequent, self.alternative)
    )

    # -----[ literals ]-----
    DEFPRINT(AST_Array, def(self, output):
        output.print('_$rapyd$_list_decorate')
        output.with_parens(def():
            output.with_square(def():
                a = self.elements
                len_ = a.length
                if len_ > 0:
                    output.space()
                a.forEach(def(exp, i):
                    if i:
                        output.comma()
                    exp.print(output)
                )
                if len_ > 0:
                    output.space()
            )
        )
    )

    def write_obj_literal(self, output):
        output.with_parens(def():
            output.print('function()')
            output.with_block(def():
                output.indent()
                if self.is_pydict:
                    output.spaced.apply(output, 'var _$rapyd$_d = _$rapyd$_dict()'.split(' '))
                else:
                    output.spaced.apply(output, 'var _$rapyd$_d = {}'.split(' '))
                output.end_statement()
                self.properties.forEach(def(prop, i):
                    output.indent()
                    if self.is_pydict:
                        output.print('_$rapyd$_d.set')
                        output.with_parens(def():
                            prop.key.print(output)
                            output.print(','), output.space()
                            prop.value.print(output)
                        )
                    else:
                        output.print('_$rapyd$_d')
                        output.with_square(def():prop.key.print(output);)
                        output.space(), output.print('='), output.space()
                        prop.value.print(output)
                    output.end_statement()
                )
                output.indent()
                output.spaced('return', '_$rapyd$_d')
                output.end_statement()
            )
        )
        output.print('()')

    DEFPRINT(AST_ExpressiveObject, write_obj_literal)

    DEFPRINT(AST_Object, def(self, output):
        if self.is_pydict:
            if self.properties.length > 0:
                write_obj_literal(self, output)
            else:
                output.print('_$rapyd$_dict()')
        else:
            if self.properties.length > 0:
                output.with_block(def():
                    self.properties.forEach(def(prop, i):
                        if i:
                            output.print(",")
                            output.newline()
                        output.indent()
                        prop.print(output)
                    )
                    output.newline()
                )
            else:
                output.print("{}")
    )
    DEFPRINT(AST_ObjectKeyVal, def(self, output):
        self.key.print(output)
        output.colon()
        self.value.print(output)
    )
    DEFPRINT(AST_Set, def(self, output):
        if self.items.length == 0:
            output.print('_$rapyd$_set()')
            return
        output.with_parens(def():
            output.print('function()')
            output.with_block(def():
                output.indent()
                output.spaced.apply(output, 'var s = _$rapyd$_set()'.split(' '))
                output.end_statement()
                self.items.forEach(def(item, i):
                    output.indent()
                    output.print('s.jsset.add')
                    output.with_parens(def():item.value.print(output);)
                    output.end_statement()
                )
                output.indent()
                output.spaced('return', 's')
                output.end_statement()
            )
        )
        output.print('()')
    )
    AST_Symbol.DEFMETHOD("definition", def():
        return this.thedef
    )
    DEFPRINT(AST_Symbol, def(self, output):
        def_ = self.definition()
        output.print_name((def_ ? def_.mangled_name or def_.name : self.name))
    )
    DEFPRINT(AST_Undefined, def(self, output):
        output.print("void 0")
    )
    DEFPRINT(AST_Hole, noop)
    DEFPRINT(AST_Infinity, def(self, output):
        output.print("1/0")
    )
    DEFPRINT(AST_NaN, def(self, output):
        output.print("0/0")
    )
    DEFPRINT(AST_This, def(self, output):
        output.print("this")
    )
    DEFPRINT(AST_Constant, def(self, output):
        output.print(self.getValue())
    )
    DEFPRINT(AST_String, def(self, output):
        output.print_string(self.getValue())
    )
    DEFPRINT(AST_Verbatim, def(self, output):
        output.print(self.getValue())
    )
    DEFPRINT(AST_Number, def(self, output):
        output.print(make_num(self.getValue()))
    )
    DEFPRINT(AST_RegExp, def(self, output):
        str_ = self.getValue().toString()
        if output.option("ascii_only"):
            str_ = output.to_ascii(str_)
        output.print(str_)
        p = output.parent()
        if isinstance(p, AST_Binary) and /^in/.test(p.operator) and p.left is self:
            output.print(" ")
    )
    def force_statement(stat, output):
        if output.option("bracketize"):
            if not stat or isinstance(stat, AST_EmptyStatement):
                output.print("{}")
            elif isinstance(stat, AST_BlockStatement):
                stat.print(output)
            else:
                output.with_block(def():
                    output.indent()
                    stat.print(output)
                    output.newline()
                )
        else:
            if not stat or isinstance(stat, AST_EmptyStatement):
                output.force_semicolon()
            else:
                stat.print(output)

    # return true if the node at the top of the stack (that means the
    # innermost node in the current output) is lexically the first in
    # a statement.
    def first_in_statement(output):
        a = output.stack()
        i = a.length
        node = a[i -= 1]
        p = a[i -= 1]
        while i > 0:
            if isinstance(p, AST_Statement) and p.body is node:
                return True
            if isinstance(p, AST_Seq) and p.car is node
            or isinstance(p, AST_BaseCall) and p.expression is node
            or isinstance(p, AST_Dot) and p.expression is node
            or isinstance(p, AST_Sub) and p.expression is node
            or isinstance(p, AST_ItemAccess) and p.expression is node
            or isinstance(p, AST_Conditional) and p.condition is node
            or isinstance(p, AST_Binary) and p.left is node
            or isinstance(p, AST_UnaryPostfix) and p.expression is node:
                node = p
                p = a[i -= 1]
            else:
                return False

    # self should be AST_New.  decide if we want to show parens or not.
    def no_constructor_parens(self, output):
        return self.args.length == 0 and not output.option("beautify")

    def best_of(a):
        best = a[0]
        len_ = best.length
        for i in range(1, a.length):
            if a[i].length < len_:
                best = a[i]
                len_ = best.length
        return best

    def make_num(num):
        str_ = num.toString(10)
        a = [ str_.replace(/^0\./, ".").replace("e+", "e") ]
        m = None

        if Math.floor(num) is num:
            if num >= 0:
                a.push("0x" + num.toString(16).toLowerCase(), # probably pointless
                "0" + num.toString(8))
            else:
                a.push("-0x" + (-num).toString(16).toLowerCase(), # probably pointless
                "-0" + (-num).toString(8))

            if m = /^(.*?)(0+)$/.exec(num):
                a.push(m[1] + "e" + m[2].length)

        elif m = /^0?\.(0+)(.*)$/.exec(num):
            a.push(m[2] + "e-" + (m[1].length + m[2].length), str_.substr(str_.indexOf(".")))

        return best_of(a)

    def make_block(stmt, output):
        if isinstance(stmt, AST_BlockStatement):
            stmt.print(output)
            return

        output.with_block(def():
            output.indent()
            stmt.print(output)
            output.newline()
        )

    # -----[ source map generators ]-----
    def DEFMAP(nodetype, generator):
        nodetype.DEFMETHOD("add_source_map", def(stream):
            generator(this, stream)
        )

    # We could easily add info for ALL nodes, but it seems to me that
    # would be quite wasteful, hence this noop in the base class.
    DEFMAP(AST_Node, noop)
    def basic_sourcemap_gen(self, output):
        output.add_mapping(self.start)

    # XXX: I'm not exactly sure if we need it for all of these nodes,
    # or if we should add even more.
    DEFMAP(AST_Directive, basic_sourcemap_gen)
    DEFMAP(AST_Debugger, basic_sourcemap_gen)
    DEFMAP(AST_Symbol, basic_sourcemap_gen)
    DEFMAP(AST_Jump, basic_sourcemap_gen)
    DEFMAP(AST_StatementWithBody, basic_sourcemap_gen)
    # since the label symbol will mark it
    DEFMAP(AST_Lambda, basic_sourcemap_gen)
    DEFMAP(AST_BlockStatement, basic_sourcemap_gen)
    DEFMAP(AST_Toplevel, noop)
    DEFMAP(AST_New, basic_sourcemap_gen)
    DEFMAP(AST_Try, basic_sourcemap_gen)
    DEFMAP(AST_Catch, basic_sourcemap_gen)
    DEFMAP(AST_Finally, basic_sourcemap_gen)
    DEFMAP(AST_Definitions, basic_sourcemap_gen)
    DEFMAP(AST_Constant, basic_sourcemap_gen)
    DEFMAP(AST_ObjectProperty, def(self, output):
        output.add_mapping(self.start, self.key)
    )

codegen()
